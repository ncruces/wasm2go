# A Wasm to Go translator

The input is a Wasm module, and the output is a single Go source file,
with no dependencies beyond the standard library.

That file forms a self contained package,
that exports a structure called `Module`,
and a `New` function to initialize it.

The methods of this structure are the Wasm module's exported functions,
whereas imports are interfaces `New` consumes.

Only a subset of the Wasm specification will be supported,
as the goal is to translate specific Wasm modules to Go.

For example, we don't need to implement SIMD,
as we can ask (e.g.) LLVM not to emit it.

We also assume the input Wasm modules can be trusted.
At a minimum, you should run Wasm modules through a verifier
before attempting to convert an untrusted module.

The current target is a useful subset of Wasm produced by `clang`.

This includes most Wasm 1.0 features, with the following exceptions:
- export aliasing (exporting the same function/global under different names);
- importing tables or globals.

It also supports a subset of Wasm 2.0 features:
- the subset of bulk memory operations that doesn't require `externref`;
- nontrapping float-to-int conversions;
- sign-extension operators;
- multi-values.

The goal is not to produce particularly readable Go code:
- because Go makes a distinction between statements and expresions,
  we use a stack-to-register approach to translate Wasm to Go;
- Wasm control flow is implemented with `goto` and labels;
- the distinction in Go between `bool` and `int32` requires
  control flow and type conversions;
- Go's untyped numeric literals require explicit type conversions;
- float operations require type conversions to avoid being combined;
- float literals can't represent negative zero, infinities, or `NaN`,
  often requiring `Float64frombits`;
- Go forbids unused variables/labels/etc.

Many of these introduce unnecessary verbosity,
but they're necessary for semantic correctness.

Judge the output by the assembly generated by the Go compiler,
not by how a human would read it.
