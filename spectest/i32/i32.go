// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"math"
	"math/bits"
)

type Module struct {
}

func New() *Module {
	m := &Module{}
	return m
}
func (m *Module) Xadd(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 + t1
	return t2
}
func (m *Module) Xsub(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 - t1
	return t2
}
func (m *Module) Xmul(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 * t1
	return t2
}
func (m *Module) Xdiv_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_div_s(t0, t1)
	return t2
}
func (m *Module) Xdiv_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := int32(uint32(t0) / uint32(t1))
	return t2
}
func (m *Module) Xrem_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 % t1
	return t2
}
func (m *Module) Xrem_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := int32(uint32(t0) % uint32(t1))
	return t2
}
func (m *Module) Xand(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 & t1
	return t2
}
func (m *Module) Xor(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 | t1
	return t2
}
func (m *Module) Xxor(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := t0 ^ t1
	return t2
}
func (m *Module) Xshl(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_shl(t0, t1)
	return t2
}
func (m *Module) Xshr_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_shr_s(t0, t1)
	return t2
}
func (m *Module) Xshr_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_shr_u(t0, t1)
	return t2
}
func (m *Module) Xrotl(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_rotl(t0, t1)
	return t2
}
func (m *Module) Xrotr(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	t2 := i32_rotr(t0, t1)
	return t2
}
func (m *Module) Xclz(v0 int32) int32 {
	t0 := v0
	t1 := int32(bits.LeadingZeros32(uint32(t0)))
	return t1
}
func (m *Module) Xctz(v0 int32) int32 {
	t0 := v0
	t1 := int32(bits.TrailingZeros32(uint32(t0)))
	return t1
}
func (m *Module) Xpopcnt(v0 int32) int32 {
	t0 := v0
	t1 := int32(bits.OnesCount32(uint32(t0)))
	return t1
}
func (m *Module) Xeqz(v0 int32) int32 {
	t0 := v0
	var t1 int32
	if t0 == 0 {
		t1 = 1
	}
	return t1
}
func (m *Module) Xeq(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 == t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xne(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 != t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xlt_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 < t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xlt_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint32(t0) < uint32(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xle_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 <= t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xle_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint32(t0) <= uint32(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xgt_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 > t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xgt_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint32(t0) > uint32(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xge_s(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 >= t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xge_u(v0 int32, v1 int32) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint32(t0) >= uint32(t1) {
		t2 = 1
	}
	return t2
}

func i32_div_s(x, y int32) int32 {
	if x == math.MinInt32 && y == -1 {
		panic("integer overflow")
	}
	return x / y
}

func i32_shl(x, y int32) int32 {
	return x << (y & 31)
}

func i32_shr_s(x, y int32) int32 {
	return x >> (y & 31)
}

func i32_shr_u(x, y int32) int32 {
	return int32(uint32(x) >> (y & 31))
}

func i32_rotl(x, y int32) int32 {
	return int32(bits.RotateLeft32(uint32(x), +int(y)&31))
}

func i32_rotr(x, y int32) int32 {
	return int32(bits.RotateLeft32(uint32(x), -int(y)&31))
}
