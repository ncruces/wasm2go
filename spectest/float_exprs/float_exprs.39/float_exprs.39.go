// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import "math"

type Module struct {
}

func New() *Module {
	m := &Module{}
	return m
}
func (m *Module) Xf32_i32_no_fold_trunc_s_convert_s(v0 float32) float32 {
	t0 := v0
	t1 := i32_trunc_f32_s(t0)
	t2 := float32(t1)
	return t2
}
func (m *Module) Xf32_i32_no_fold_trunc_u_convert_s(v0 float32) float32 {
	t0 := v0
	t1 := i32_trunc_f32_u(t0)
	t2 := float32(t1)
	return t2
}
func (m *Module) Xf32_i32_no_fold_trunc_s_convert_u(v0 float32) float32 {
	t0 := v0
	t1 := i32_trunc_f32_s(t0)
	t2 := float32(uint32(t1))
	return t2
}
func (m *Module) Xf32_i32_no_fold_trunc_u_convert_u(v0 float32) float32 {
	t0 := v0
	t1 := i32_trunc_f32_u(t0)
	t2 := float32(uint32(t1))
	return t2
}
func (m *Module) Xf64_i32_no_fold_trunc_s_convert_s(v0 float64) float64 {
	t0 := v0
	t1 := i32_trunc_f64_s(t0)
	t2 := float64(t1)
	return t2
}
func (m *Module) Xf64_i32_no_fold_trunc_u_convert_s(v0 float64) float64 {
	t0 := v0
	t1 := i32_trunc_f64_u(t0)
	t2 := float64(t1)
	return t2
}
func (m *Module) Xf64_i32_no_fold_trunc_s_convert_u(v0 float64) float64 {
	t0 := v0
	t1 := i32_trunc_f64_s(t0)
	t2 := float64(uint32(t1))
	return t2
}
func (m *Module) Xf64_i32_no_fold_trunc_u_convert_u(v0 float64) float64 {
	t0 := v0
	t1 := i32_trunc_f64_u(t0)
	t2 := float64(uint32(t1))
	return t2
}
func (m *Module) Xf32_i64_no_fold_trunc_s_convert_s(v0 float32) float32 {
	t0 := v0
	t1 := i64_trunc_f32_s(t0)
	t2 := float32(t1)
	return t2
}
func (m *Module) Xf32_i64_no_fold_trunc_u_convert_s(v0 float32) float32 {
	t0 := v0
	t1 := i64_trunc_f32_u(t0)
	t2 := float32(t1)
	return t2
}
func (m *Module) Xf32_i64_no_fold_trunc_s_convert_u(v0 float32) float32 {
	t0 := v0
	t1 := i64_trunc_f32_s(t0)
	t2 := float32(uint64(t1))
	return t2
}
func (m *Module) Xf32_i64_no_fold_trunc_u_convert_u(v0 float32) float32 {
	t0 := v0
	t1 := i64_trunc_f32_u(t0)
	t2 := float32(uint64(t1))
	return t2
}
func (m *Module) Xf64_i64_no_fold_trunc_s_convert_s(v0 float64) float64 {
	t0 := v0
	t1 := i64_trunc_f64_s(t0)
	t2 := float64(t1)
	return t2
}
func (m *Module) Xf64_i64_no_fold_trunc_u_convert_s(v0 float64) float64 {
	t0 := v0
	t1 := i64_trunc_f64_u(t0)
	t2 := float64(t1)
	return t2
}
func (m *Module) Xf64_i64_no_fold_trunc_s_convert_u(v0 float64) float64 {
	t0 := v0
	t1 := i64_trunc_f64_s(t0)
	t2 := float64(uint64(t1))
	return t2
}
func (m *Module) Xf64_i64_no_fold_trunc_u_convert_u(v0 float64) float64 {
	t0 := v0
	t1 := i64_trunc_f64_u(t0)
	t2 := float64(uint64(t1))
	return t2
}

func i32_trunc_f64_s(f float64) int32 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < math.MinInt32 ||
		x > math.MaxInt32 {
		panic("invalid conversion to integer")
	}
	return int32(x)
}

func i32_trunc_f32_s(f float32) int32 {
	x := math.Trunc(float64(f))
	if math.IsNaN(x) ||
		x < math.MinInt32 ||
		x > math.MaxInt32 {
		panic("invalid conversion to integer")
	}
	return int32(x)
}

func i32_trunc_f64_u(f float64) int32 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < 0 ||
		x > math.MaxUint32 {
		panic("invalid conversion to integer")
	}
	return int32(uint32(x))
}

func i32_trunc_f32_u(f float32) int32 {
	x := math.Trunc(float64(f))
	if math.IsNaN(x) ||
		x < 0 ||
		x > math.MaxUint32 {
		panic("invalid conversion to integer")
	}
	return int32(uint32(x))
}

func i64_trunc_f64_s(f float64) int64 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < math.MinInt64 ||
		x >= math.MaxInt64 {
		panic("invalid conversion to integer")
	}
	return int64(x)
}

func i64_trunc_f32_s(f float32) int64 {
	x := math.Trunc(float64(f))
	if math.IsNaN(x) ||
		x < math.MinInt64 ||
		x >= math.MaxInt64 {
		panic("invalid conversion to integer")
	}
	return int64(x)
}

func i64_trunc_f64_u(f float64) int64 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < 0 ||
		x >= math.MaxUint64 {
		panic("invalid conversion to integer")
	}
	return int64(uint64(x))
}

func i64_trunc_f32_u(f float32) int64 {
	x := math.Trunc(float64(f))
	if math.IsNaN(x) || x < 0 ||
		x >= math.MaxUint64 {
		panic("invalid conversion to integer")
	}
	return int64(uint64(x))
}
