// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"encoding/binary"
	"math"
)

type Module struct {
	memory []byte
	maxMem int32
}

func New() *Module {
	m := &Module{}
	m.maxMem = 65536
	m.memory = make([]byte, 65536)
	return m
}
func (m *Module) Xf32_align_switch(v0 int32) float32 {
	var v1, v2 float32
	_, _ = v1, v2
	v1 = float32(10)
	{
		{
			{
				{
					{
						t0 := v0
						switch t0 {
						default:
							goto l0
						case 0:
							goto l1
						case 1:
							goto l2
						case 2:
							goto l3
						case 3:
							goto l4
						}
					}
				l1:
					;
					t1 := v1
					binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], math.Float32bits(t1))
					t2 := math.Float32frombits(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
					v2 = t2
					goto l0
				}
			l2:
				;
				t3 := v1
				binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], math.Float32bits(t3))
				t4 := math.Float32frombits(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
				v2 = t4
				goto l0
			}
		l3:
			;
			t5 := v1
			binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], math.Float32bits(t5))
			t6 := math.Float32frombits(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
			v2 = t6
			goto l0
		}
	l4:
		;
		t7 := v1
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], math.Float32bits(t7))
		t8 := math.Float32frombits(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
		v2 = t8
	}
l0:
	;
	t9 := v2
	return t9
}
func (m *Module) Xf64_align_switch(v0 int32) float64 {
	var v1, v2 float64
	_, _ = v1, v2
	v1 = float64(10)
	{
		{
			{
				{
					{
						{
							t0 := v0
							switch t0 {
							default:
								goto l0
							case 0:
								goto l1
							case 1:
								goto l2
							case 2:
								goto l3
							case 3:
								goto l4
							case 4:
								goto l5
							}
						}
					l1:
						;
						t1 := v1
						binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], math.Float64bits(t1))
						t2 := math.Float64frombits(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
						v2 = t2
						goto l0
					}
				l2:
					;
					t3 := v1
					binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], math.Float64bits(t3))
					t4 := math.Float64frombits(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
					v2 = t4
					goto l0
				}
			l3:
				;
				t5 := v1
				binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], math.Float64bits(t5))
				t6 := math.Float64frombits(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
				v2 = t6
				goto l0
			}
		l4:
			;
			t7 := v1
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], math.Float64bits(t7))
			t8 := math.Float64frombits(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v2 = t8
			goto l0
		}
	l5:
		;
		t9 := v1
		binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], math.Float64bits(t9))
		t10 := math.Float64frombits(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
		v2 = t10
	}
l0:
	;
	t11 := v2
	return t11
}
func (m *Module) Xi32_align_switch(v0 int32, v1 int32) int32 {
	var v2, v3 int32
	_, _ = v2, v3
	v2 = int32(10)
	{
		{
			{
				{
					{
						{
							t0 := v0
							switch t0 {
							default:
								goto l0
							case 0:
								goto l1
							case 1:
								goto l2
							case 2:
								goto l3
							case 3:
								goto l4
							case 4:
								goto l5
							}
						}
					l1:
						;
						t1 := v1
						if t1 == i32_const(0) {
							t3 := v2
							m.memory[uint32(i32_const(0))] = byte(t3)
							t4 := int32(int8(m.memory[uint32(i32_const(0))]))
							v3 = t4
						}
						t5 := v1
						if t5 == int32(1) {
							t7 := v2
							m.memory[uint32(i32_const(0))] = byte(t7)
							t8 := int32(int8(m.memory[uint32(i32_const(0))]))
							v3 = t8
						}
						goto l0
					}
				l2:
					;
					t9 := v1
					if t9 == i32_const(0) {
						t11 := v2
						m.memory[uint32(i32_const(0))] = byte(t11)
						t12 := int32(m.memory[uint32(i32_const(0))])
						v3 = t12
					}
					t13 := v1
					if t13 == int32(1) {
						t15 := v2
						m.memory[uint32(i32_const(0))] = byte(t15)
						t16 := int32(m.memory[uint32(i32_const(0))])
						v3 = t16
					}
					goto l0
				}
			l3:
				;
				t17 := v1
				if t17 == i32_const(0) {
					t19 := v2
					binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t19))
					t20 := int32(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
					v3 = t20
				}
				t21 := v1
				if t21 == int32(1) {
					t23 := v2
					binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t23))
					t24 := int32(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
					v3 = t24
				}
				t25 := v1
				if t25 == int32(2) {
					t27 := v2
					binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t27))
					t28 := int32(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
					v3 = t28
				}
				goto l0
			}
		l4:
			;
			t29 := v1
			if t29 == i32_const(0) {
				t31 := v2
				binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t31))
				t32 := int32(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
				v3 = t32
			}
			t33 := v1
			if t33 == int32(1) {
				t35 := v2
				binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t35))
				t36 := int32(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
				v3 = t36
			}
			t37 := v1
			if t37 == int32(2) {
				t39 := v2
				binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t39))
				t40 := int32(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
				v3 = t40
			}
			goto l0
		}
	l5:
		;
		t41 := v1
		if t41 == i32_const(0) {
			t43 := v2
			binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t43))
			t44 := int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
			v3 = t44
		}
		t45 := v1
		if t45 == int32(1) {
			t47 := v2
			binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t47))
			t48 := int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
			v3 = t48
		}
		t49 := v1
		if t49 == int32(2) {
			t51 := v2
			binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t51))
			t52 := int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
			v3 = t52
		}
		t53 := v1
		if t53 == int32(4) {
			t55 := v2
			binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t55))
			t56 := int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
			v3 = t56
		}
	}
l0:
	;
	t57 := v3
	return t57
}
func (m *Module) Xi64_align_switch(v0 int32, v1 int32) int64 {
	var v2, v3 int64
	_, _ = v2, v3
	v2 = int64(10)
	{
		{
			{
				{
					{
						{
							{
								{
									t0 := v0
									switch t0 {
									default:
										goto l0
									case 0:
										goto l1
									case 1:
										goto l2
									case 2:
										goto l3
									case 3:
										goto l4
									case 4:
										goto l5
									case 5:
										goto l6
									case 6:
										goto l7
									}
								}
							l1:
								;
								t1 := v1
								if t1 == i32_const(0) {
									t3 := v2
									m.memory[uint32(i32_const(0))] = byte(t3)
									t4 := int64(int8(m.memory[uint32(i32_const(0))]))
									v3 = t4
								}
								t5 := v1
								if t5 == int32(1) {
									t7 := v2
									m.memory[uint32(i32_const(0))] = byte(t7)
									t8 := int64(int8(m.memory[uint32(i32_const(0))]))
									v3 = t8
								}
								goto l0
							}
						l2:
							;
							t9 := v1
							if t9 == i32_const(0) {
								t11 := v2
								m.memory[uint32(i32_const(0))] = byte(t11)
								t12 := int64(m.memory[uint32(i32_const(0))])
								v3 = t12
							}
							t13 := v1
							if t13 == int32(1) {
								t15 := v2
								m.memory[uint32(i32_const(0))] = byte(t15)
								t16 := int64(m.memory[uint32(i32_const(0))])
								v3 = t16
							}
							goto l0
						}
					l3:
						;
						t17 := v1
						if t17 == i32_const(0) {
							t19 := v2
							binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t19))
							t20 := int64(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
							v3 = t20
						}
						t21 := v1
						if t21 == int32(1) {
							t23 := v2
							binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t23))
							t24 := int64(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
							v3 = t24
						}
						t25 := v1
						if t25 == int32(2) {
							t27 := v2
							binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t27))
							t28 := int64(int16(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):])))
							v3 = t28
						}
						goto l0
					}
				l4:
					;
					t29 := v1
					if t29 == i32_const(0) {
						t31 := v2
						binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t31))
						t32 := int64(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
						v3 = t32
					}
					t33 := v1
					if t33 == int32(1) {
						t35 := v2
						binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t35))
						t36 := int64(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
						v3 = t36
					}
					t37 := v1
					if t37 == int32(2) {
						t39 := v2
						binary.LittleEndian.PutUint16(m.memory[uint32(i32_const(0)):], uint16(t39))
						t40 := int64(binary.LittleEndian.Uint16(m.memory[uint32(i32_const(0)):]))
						v3 = t40
					}
					goto l0
				}
			l5:
				;
				t41 := v1
				if t41 == i32_const(0) {
					t43 := v2
					binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t43))
					t44 := int64(int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):])))
					v3 = t44
				}
				t45 := v1
				if t45 == int32(1) {
					t47 := v2
					binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t47))
					t48 := int64(int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):])))
					v3 = t48
				}
				t49 := v1
				if t49 == int32(2) {
					t51 := v2
					binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t51))
					t52 := int64(int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):])))
					v3 = t52
				}
				t53 := v1
				if t53 == int32(4) {
					t55 := v2
					binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t55))
					t56 := int64(int32(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):])))
					v3 = t56
				}
				goto l0
			}
		l6:
			;
			t57 := v1
			if t57 == i32_const(0) {
				t59 := v2
				binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t59))
				t60 := int64(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
				v3 = t60
			}
			t61 := v1
			if t61 == int32(1) {
				t63 := v2
				binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t63))
				t64 := int64(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
				v3 = t64
			}
			t65 := v1
			if t65 == int32(2) {
				t67 := v2
				binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t67))
				t68 := int64(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
				v3 = t68
			}
			t69 := v1
			if t69 == int32(4) {
				t71 := v2
				binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(t71))
				t72 := int64(binary.LittleEndian.Uint32(m.memory[uint32(i32_const(0)):]))
				v3 = t72
			}
			goto l0
		}
	l7:
		;
		t73 := v1
		if t73 == i32_const(0) {
			t75 := v2
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], uint64(t75))
			t76 := int64(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v3 = t76
		}
		t77 := v1
		if t77 == int32(1) {
			t79 := v2
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], uint64(t79))
			t80 := int64(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v3 = t80
		}
		t81 := v1
		if t81 == int32(2) {
			t83 := v2
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], uint64(t83))
			t84 := int64(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v3 = t84
		}
		t85 := v1
		if t85 == int32(4) {
			t87 := v2
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], uint64(t87))
			t88 := int64(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v3 = t88
		}
		t89 := v1
		if t89 == int32(8) {
			t91 := v2
			binary.LittleEndian.PutUint64(m.memory[uint32(i32_const(0)):], uint64(t91))
			t92 := int64(binary.LittleEndian.Uint64(m.memory[uint32(i32_const(0)):]))
			v3 = t92
		}
	}
l0:
	;
	t93 := v3
	return t93
}

func i32_const(x int32) int32 { return x }
