// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"encoding/binary"
	"math"
)

type Module struct {
	table    []any
	elements [][]any
	memory   []byte
	maxMem   int32
	_g       int32
}

func New() *Module {
	m := &Module{}
	m.table = make([]any, 1)
	m.maxMem = 65536
	m.memory = make([]byte, 65536)
	m.elements = [][]any{[]any{m._f}}
	copy(m.table[0:], m.elements[0])
	m._g = i32_const(0)
	return m
}
func (m *Module) Xtype_local_i32() int32 {
	var v0 int32
	_ = v0
	v0 = i32_const(0)
	return i32_const(0)
}
func (m *Module) Xtype_local_i64() int64 {
	var v0 int64
	_ = v0
	v0 = i64_const(0)
	return i64_const(0)
}
func (m *Module) Xtype_local_f32() float32 {
	var v0 float32
	_ = v0
	v0 = float32(0)
	return float32(0)
}
func (m *Module) Xtype_local_f64() float64 {
	var v0 float64
	_ = v0
	v0 = float64(0)
	return float64(0)
}
func (m *Module) Xtype_param_i32(v0 int32) int32 {
	v0 = int32(10)
	return int32(10)
}
func (m *Module) Xtype_param_i64(v0 int64) int64 {
	v0 = int64(11)
	return int64(11)
}
func (m *Module) Xtype_param_f32(v0 float32) float32 {
	v0 = float32(11.1)
	return float32(11.1)
}
func (m *Module) Xtype_param_f64(v0 float64) float64 {
	v0 = float64(12.2)
	return float64(12.2)
}
func (m *Module) Xtype_mixed(v0 int64, v1 float32, v2 float64, v3 int32, v4 int32) {
	var v5 float32
	_ = v5
	var v6, v7 int64
	_, _ = v6, v7
	var v8 float64
	_ = v8
	v0 = i64_const(0)
	var t0 int32
	if i64_const(0) == 0 {
		t0 = 1
	}
	_ = t0
	v1 = float32(0)
	t1 := -float32(0)
	_ = t1
	v2 = float64(0)
	t2 := -float64(0)
	_ = t2
	v3 = i32_const(0)
	var t3 int32
	if i32_const(0) == 0 {
		t3 = 1
	}
	_ = t3
	v4 = i32_const(0)
	var t4 int32
	if i32_const(0) == 0 {
		t4 = 1
	}
	_ = t4
	v5 = float32(0)
	t5 := -float32(0)
	_ = t5
	v6 = i64_const(0)
	var t6 int32
	if i64_const(0) == 0 {
		t6 = 1
	}
	_ = t6
	v7 = i64_const(0)
	var t7 int32
	if i64_const(0) == 0 {
		t7 = 1
	}
	_ = t7
	v8 = float64(0)
	t8 := -float64(0)
	_ = t8
}
func (m *Module) Xwrite(v0 int64, v1 float32, v2 float64, v3 int32, v4 int32) int64 {
	var v5 float32
	_ = v5
	var v6, v7 int64
	_, _ = v6, v7
	var v8 float64
	_ = v8
	v1 = float32(-0.3)
	_ = float32(-0.3)
	v3 = int32(40)
	_ = int32(40)
	v4 = i32_const(-7)
	_ = i32_const(-7)
	v5 = float32(5.5)
	_ = float32(5.5)
	v6 = int64(6)
	_ = int64(6)
	v8 = float64(8)
	_ = float64(8)
	t0 := v0
	t1 := float64(uint64(t0))
	t2 := v1
	t3 := float64(t2)
	t4 := v2
	t5 := v3
	t6 := float64(uint32(t5))
	t7 := v4
	t8 := float64(t7)
	t9 := v5
	t10 := float64(t9)
	t11 := v6
	t12 := float64(uint64(t11))
	t13 := v7
	t14 := float64(uint64(t13))
	t15 := v8
	t16 := float64(t14 + t15)
	t17 := float64(t12 + t16)
	t18 := float64(t10 + t17)
	t19 := float64(t8 + t18)
	t20 := float64(t6 + t19)
	t21 := float64(t4 + t20)
	t22 := float64(t3 + t21)
	t23 := float64(t1 + t22)
	t24 := i64_trunc_f64_s(t23)
	return t24
}
func (m *Module) Xresult(v0 int64, v1 float32, v2 float64, v3 int32, v4 int32) float64 {
	var v5 float32
	_ = v5
	var v6, v7 int64
	_, _ = v6, v7
	var v8 float64
	_ = v8
	v0 = int64(1)
	t0 := float64(uint64(int64(1)))
	v1 = float32(2)
	t1 := float64(float32(2))
	v2 = float64(3.3)
	v3 = int32(4)
	t2 := float64(uint32(int32(4)))
	v4 = int32(5)
	t3 := float64(int32(5))
	v5 = float32(5.5)
	t4 := float64(float32(5.5))
	v6 = int64(6)
	t5 := float64(uint64(int64(6)))
	v7 = i64_const(0)
	t6 := float64(uint64(i64_const(0)))
	v8 = float64(8)
	t7 := float64(t6 + float64(8))
	t8 := float64(t5 + t7)
	t9 := float64(t4 + t8)
	t10 := float64(t3 + t9)
	t11 := float64(t2 + t10)
	t12 := float64(float64(3.3) + t11)
	t13 := float64(t1 + t12)
	t14 := float64(t0 + t13)
	return t14
}
func (m *Module) _dummy() {
}
func (m *Module) Xas_block_first(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(1)
		m._dummy()
		t0 = int32(1)
	}
	return t0
}
func (m *Module) Xas_block_mid(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		v0 = int32(1)
		m._dummy()
		t0 = int32(1)
	}
	return t0
}
func (m *Module) Xas_block_last(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		m._dummy()
		v0 = int32(1)
		t0 = int32(1)
	}
	return t0
}
func (m *Module) Xas_loop_first(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(3)
		m._dummy()
		t0 = int32(3)
	}
	return t0
}
func (m *Module) Xas_loop_mid(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		v0 = int32(4)
		m._dummy()
		t0 = int32(4)
	}
	return t0
}
func (m *Module) Xas_loop_last(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		m._dummy()
		v0 = int32(5)
		t0 = int32(5)
	}
	return t0
}
func (m *Module) Xas_br_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(9)
		t0 = int32(9)
		goto l0
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_if_cond(v0 int32) {
	{
		v0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_if_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(8)
		t0 = int32(8)
		if int32(1) != 0 {
			goto l0
		}
		_ = int32(8)
		t0 = int32(7)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_if_value_cond(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(9)
		t0 = int32(6)
		if int32(9) != 0 {
			goto l0
		}
		_ = int32(6)
		t0 = int32(7)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_index(v0 int32) {
	{
		v0 = i32_const(0)
		switch i32_const(0) {
		default:
			goto l0
		case 0:
			goto l0
		case 1:
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_table_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(10)
		t0 = int32(10)
		t0 = int32(10)
		t0 = int32(10)
		switch int32(1) {
		default:
			goto l0
		case 0:
			goto l0
		case 1:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_value_index(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		v0 = int32(11)
		t0 = int32(6)
		t0 = int32(6)
		switch int32(11) {
		default:
			goto l0
		case 0:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_return_value(v0 int32) int32 {
	v0 = int32(7)
	return int32(7)
}
func (m *Module) Xas_if_cond(v0 int32) int32 {
	v0 = int32(2)
	var t0 int32
	_ = t0
	if int32(2) != 0 {
		t0 = i32_const(0)
	} else {
		t0 = int32(1)
	}
	return t0
}
func (m *Module) Xas_if_then(v0 int32) int32 {
	t0 := v0
	var t1 int32
	_ = t1
	if t0 != 0 {
		v0 = int32(3)
		t1 = int32(3)
	} else {
		t2 := v0
		t1 = t2
	}
	return t1
}
func (m *Module) Xas_if_else(v0 int32) int32 {
	t0 := v0
	var t1 int32
	_ = t1
	if t0 != 0 {
		t2 := v0
		t1 = t2
	} else {
		v0 = int32(4)
		t1 = int32(4)
	}
	return t1
}
func (m *Module) Xas_select_first(v0 int32, v1 int32) int32 {
	v0 = int32(5)
	t0 := v0
	t1 := v1
	t2 := t0
	if t1 != 0 {
		t2 = int32(5)
	}
	return t2
}
func (m *Module) Xas_select_second(v0 int32, v1 int32) int32 {
	t0 := v0
	v0 = int32(6)
	t1 := v1
	t2 := int32(6)
	if t1 != 0 {
		t2 = t0
	}
	return t2
}
func (m *Module) Xas_select_cond(v0 int32) int32 {
	v0 = int32(7)
	t0 := int32(1)
	if int32(7) != 0 {
		t0 = i32_const(0)
	}
	return t0
}
func (m *Module) _f(v0 int32, v1 int32, v2 int32) int32 {
	return i32_const(-1)
}
func (m *Module) Xas_call_first(v0 int32) int32 {
	v0 = int32(12)
	t0 := m._f(int32(12), int32(2), int32(3))
	return t0
}
func (m *Module) Xas_call_mid(v0 int32) int32 {
	v0 = int32(13)
	t0 := m._f(int32(1), int32(13), int32(3))
	return t0
}
func (m *Module) Xas_call_last(v0 int32) int32 {
	v0 = int32(14)
	t0 := m._f(int32(1), int32(2), int32(14))
	return t0
}
func (m *Module) Xas_call_indirect_first(v0 int32) int32 {
	v0 = int32(1)
	t0 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(3))
	return t0
}
func (m *Module) Xas_call_indirect_mid(v0 int32) int32 {
	v0 = int32(2)
	t0 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(3))
	return t0
}
func (m *Module) Xas_call_indirect_last(v0 int32) int32 {
	v0 = int32(3)
	t0 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(3))
	return t0
}
func (m *Module) Xas_call_indirect_index(v0 int32) int32 {
	v0 = i32_const(0)
	t0 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(3))
	return t0
}
func (m *Module) Xas_local_set_value() {
	var v0 int32
	_ = v0
	v0 = int32(1)
	v0 = int32(1)
}
func (m *Module) Xas_local_tee_value(v0 int32) int32 {
	v0 = int32(1)
	v0 = int32(1)
	return int32(1)
}
func (m *Module) Xas_global_set_value() {
	var v0 int32
	_ = v0
	v0 = int32(1)
	m._g = int32(1)
}
func (m *Module) Xas_load_address(v0 int32) int32 {
	v0 = int32(1)
	t0 := int32(binary.LittleEndian.Uint32(m.memory[uint32(int32(1)):]))
	return t0
}
func (m *Module) Xas_loadN_address(v0 int32) int32 {
	v0 = int32(3)
	t0 := int32(int8(m.memory[uint32(int32(3))]))
	return t0
}
func (m *Module) Xas_store_address(v0 int32) {
	v0 = int32(30)
	binary.LittleEndian.PutUint32(m.memory[uint32(int32(30)):], uint32(int32(7)))
}
func (m *Module) Xas_store_value(v0 int32) {
	v0 = int32(1)
	binary.LittleEndian.PutUint32(m.memory[uint32(int32(2)):], uint32(int32(1)))
}
func (m *Module) Xas_storeN_address(v0 int32) {
	v0 = int32(1)
	m.memory[uint32(int32(1))] = byte(int32(7))
}
func (m *Module) Xas_storeN_value(v0 int32) {
	v0 = int32(1)
	binary.LittleEndian.PutUint16(m.memory[uint32(int32(2)):], uint16(int32(1)))
}
func (m *Module) Xas_unary_operand(v0 float32) float32 {
	v0 = math.Float32frombits(2139156962)
	t0 := -math.Float32frombits(2139156962)
	return t0
}
func (m *Module) Xas_binary_left(v0 int32) int32 {
	v0 = int32(3)
	t0 := int32(3) + int32(10)
	return t0
}
func (m *Module) Xas_binary_right(v0 int32) int32 {
	v0 = int32(4)
	t0 := int32(10) - int32(4)
	return t0
}
func (m *Module) Xas_test_operand(v0 int32) int32 {
	v0 = i32_const(0)
	var t0 int32
	if i32_const(0) == 0 {
		t0 = 1
	}
	return t0
}
func (m *Module) Xas_compare_left(v0 int32) int32 {
	v0 = int32(43)
	var t0 int32
	if int32(43) <= int32(10) {
		t0 = 1
	}
	return t0
}
func (m *Module) Xas_compare_right(v0 int32) int32 {
	v0 = int32(42)
	var t0 int32
	if int32(10) != int32(42) {
		t0 = 1
	}
	return t0
}
func (m *Module) Xas_convert_operand(v0 int64) int32 {
	v0 = int64(41)
	t0 := int32(int64(41))
	return t0
}
func (m *Module) Xas_memory_grow_size(v0 int32) int32 {
	v0 = int32(40)
	t0 := memory_grow(&m.memory, int32(40), m.maxMem)
	return t0
}

func i32_const(x int32) int32 { return x }

func i64_const(x int64) int64 { return x }

func i64_trunc_f64_s(f float64) int64 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < math.MinInt64 ||
		x >= math.MaxInt64 {
		panic("invalid conversion to integer")
	}
	return int64(x)
}

func memory_grow(mem *[]byte, delta, max int32) int32 {
	buf := *mem
	len := len(buf)
	old := int32(len >> 16)
	if delta == 0 {
		return old
	}
	new := old + delta
	add := int(new)<<16 - len
	if new > max || add < 0 {
		return -1
	}
	*mem = append(buf, make([]byte, add)...)
	return old
}
