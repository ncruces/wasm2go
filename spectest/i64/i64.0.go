// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"math"
	"math/bits"
)

type Module struct {
}

func New() *Module {
	m := &Module{}
	return m
}
func (m *Module) Xadd(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 + t1
	return t2
}
func (m *Module) Xsub(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 - t1
	return t2
}
func (m *Module) Xmul(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 * t1
	return t2
}
func (m *Module) Xdiv_s(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_div_s(t0, t1)
	return t2
}
func (m *Module) Xdiv_u(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := int64(uint64(t0) / uint64(t1))
	return t2
}
func (m *Module) Xrem_s(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 % t1
	return t2
}
func (m *Module) Xrem_u(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := int64(uint64(t0) % uint64(t1))
	return t2
}
func (m *Module) Xand(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 & t1
	return t2
}
func (m *Module) Xor(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 | t1
	return t2
}
func (m *Module) Xxor(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := t0 ^ t1
	return t2
}
func (m *Module) Xshl(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_shl(t0, t1)
	return t2
}
func (m *Module) Xshr_s(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_shr_s(t0, t1)
	return t2
}
func (m *Module) Xshr_u(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_shr_u(t0, t1)
	return t2
}
func (m *Module) Xrotl(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_rotl(t0, t1)
	return t2
}
func (m *Module) Xrotr(v0 int64, v1 int64) int64 {
	t0 := v0
	t1 := v1
	t2 := i64_rotr(t0, t1)
	return t2
}
func (m *Module) Xclz(v0 int64) int64 {
	t0 := v0
	t1 := int64(bits.LeadingZeros64(uint64(t0)))
	return t1
}
func (m *Module) Xctz(v0 int64) int64 {
	t0 := v0
	t1 := int64(bits.TrailingZeros64(uint64(t0)))
	return t1
}
func (m *Module) Xpopcnt(v0 int64) int64 {
	t0 := v0
	t1 := int64(bits.OnesCount64(uint64(t0)))
	return t1
}
func (m *Module) Xeqz(v0 int64) int32 {
	t0 := v0
	var t1 int32
	if t0 == 0 {
		t1 = 1
	}
	return t1
}
func (m *Module) Xeq(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 == t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xne(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 != t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xlt_s(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 < t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xlt_u(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint64(t0) < uint64(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xle_s(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 <= t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xle_u(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint64(t0) <= uint64(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xgt_s(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 > t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xgt_u(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint64(t0) > uint64(t1) {
		t2 = 1
	}
	return t2
}
func (m *Module) Xge_s(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if t0 >= t1 {
		t2 = 1
	}
	return t2
}
func (m *Module) Xge_u(v0 int64, v1 int64) int32 {
	t0 := v0
	t1 := v1
	var t2 int32
	if uint64(t0) >= uint64(t1) {
		t2 = 1
	}
	return t2
}

func i64_div_s(x, y int64) int64 {
	if x == math.MinInt64 && y == -1 {
		panic("integer overflow")
	}
	return x / y
}

func i64_shl(x, y int64) int64 {
	return x << (y & 63)
}

func i64_shr_s(x, y int64) int64 {
	return x >> (y & 63)
}

func i64_shr_u(x, y int64) int64 {
	return int64(uint64(x) >> (y & 63))
}

func i64_rotl(x, y int64) int64 {
	return int64(bits.RotateLeft64(uint64(x), +int(y)&63))
}

func i64_rotr(x, y int64) int64 {
	return int64(bits.RotateLeft64(uint64(x), -int(y)&63))
}
