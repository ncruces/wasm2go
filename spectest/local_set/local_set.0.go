// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import "math"

type Module struct {
}

func New() *Module {
	m := &Module{}
	return m
}
func (m *Module) Xtype_local_i32() {
	var v0 int32
	_ = v0
	v0 = i32_const(0)
}
func (m *Module) Xtype_local_i64() {
	var v0 int64
	_ = v0
	v0 = i64_const(0)
}
func (m *Module) Xtype_local_f32() {
	var v0 float32
	_ = v0
	v0 = float32(0)
}
func (m *Module) Xtype_local_f64() {
	var v0 float64
	_ = v0
	v0 = float64(0)
}
func (m *Module) Xtype_param_i32(v0 int32) {
	v0 = int32(10)
}
func (m *Module) Xtype_param_i64(v0 int64) {
	v0 = int64(11)
}
func (m *Module) Xtype_param_f32(v0 float32) {
	v0 = float32(11.1)
}
func (m *Module) Xtype_param_f64(v0 float64) {
	v0 = float64(12.2)
}
func (m *Module) Xtype_mixed(v0 int64, v1 float32, v2 float64, v3 int32, v4 int32) {
	var v5 float32
	_ = v5
	var v6, v7 int64
	_, _ = v6, v7
	var v8 float64
	_ = v8
	v0 = i64_const(0)
	v1 = float32(0)
	v2 = float64(0)
	v3 = i32_const(0)
	v4 = i32_const(0)
	v5 = float32(0)
	v6 = i64_const(0)
	v7 = i64_const(0)
	v8 = float64(0)
}
func (m *Module) Xwrite(v0 int64, v1 float32, v2 float64, v3 int32, v4 int32) int64 {
	var v5 float32
	_ = v5
	var v6, v7 int64
	_, _ = v6, v7
	var v8 float64
	_ = v8
	v1 = float32(-0.3)
	v3 = int32(40)
	v4 = i32_const(-7)
	v5 = float32(5.5)
	v6 = int64(6)
	v8 = float64(8)
	t0 := v0
	t1 := float64(uint64(t0))
	t2 := v1
	t3 := float64(t2)
	t4 := v2
	t5 := v3
	t6 := float64(uint32(t5))
	t7 := v4
	t8 := float64(t7)
	t9 := v5
	t10 := float64(t9)
	t11 := v6
	t12 := float64(uint64(t11))
	t13 := v7
	t14 := float64(uint64(t13))
	t15 := v8
	t16 := float64(t14 + t15)
	t17 := float64(t12 + t16)
	t18 := float64(t10 + t17)
	t19 := float64(t8 + t18)
	t20 := float64(t6 + t19)
	t21 := float64(t4 + t20)
	t22 := float64(t3 + t21)
	t23 := float64(t1 + t22)
	t24 := i64_trunc_f64_s(t23)
	return t24
}
func (m *Module) Xas_block_value(v0 int32) {
	{
		v0 = int32(1)
	}
}
func (m *Module) Xas_loop_value(v0 int32) {
	{
		v0 = int32(3)
	}
}
func (m *Module) Xas_br_value(v0 int32) {
	{
		v0 = int32(9)
		goto l0
	}
l0:
}
func (m *Module) Xas_br_if_value(v0 int32) {
	{
		v0 = int32(8)
		if int32(1) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_if_value_cond(v0 int32) {
	{
		v0 = int32(9)
		if int32(6) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_table_value(v0 int32) {
	{
		v0 = int32(10)
		switch int32(1) {
		default:
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_return_value(v0 int32) {
	v0 = int32(7)
	return
}
func (m *Module) Xas_if_then(v0 int32) {
	t0 := v0
	if t0 != 0 {
		v0 = int32(3)
	}
}
func (m *Module) Xas_if_else(v0 int32) {
	t0 := v0
	if t0 != 0 {
	} else {
		v0 = int32(1)
	}
}

func i32_const(x int32) int32 { return x }

func i64_const(x int64) int64 { return x }

func i64_trunc_f64_s(f float64) int64 {
	x := math.Trunc(f)
	if math.IsNaN(x) ||
		x < math.MinInt64 ||
		x >= math.MaxInt64 {
		panic("invalid conversion to integer")
	}
	return int64(x)
}
