// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"encoding/binary"
	"math/bits"
)

type Module struct {
	table    []any
	elements [][]any
	memory   []byte
	maxMem   int32
	_a       int32
}

func New() *Module {
	m := &Module{}
	m.table = make([]any, 1)
	m.maxMem = 65536
	m.memory = make([]byte, 65536)
	m.elements = [][]any{[]any{m._func}}
	copy(m.table[0:], m.elements[0])
	m._a = int32(10)
	return m
}
func (m *Module) _dummy() {
}
func (m *Module) Xtype_i32() {
	{
		if int32(1) != 0 {
			goto l0
		}
		t0 := int32(bits.TrailingZeros32(uint32(i32_const(0))))
		_ = t0
	}
l0:
}
func (m *Module) Xtype_i64() {
	{
		if int32(1) != 0 {
			goto l0
		}
		t0 := int64(bits.TrailingZeros64(uint64(i64_const(0))))
		_ = t0
	}
l0:
}
func (m *Module) Xtype_f32() {
	{
		if int32(1) != 0 {
			goto l0
		}
		t0 := -float32(0)
		_ = t0
	}
l0:
}
func (m *Module) Xtype_f64() {
	{
		if int32(1) != 0 {
			goto l0
		}
		t0 := -float64(0)
		_ = t0
	}
l0:
}
func (m *Module) Xtype_i32_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int32(bits.TrailingZeros32(uint32(int32(1))))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xtype_i64_value() int64 {
	var t0 int64
	_ = t0
	{
		t0 = int64(2)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int64(bits.TrailingZeros64(uint64(int64(2))))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xtype_f32_value() float32 {
	var t0 float32
	_ = t0
	{
		t0 = float32(3)
		if int32(1) != 0 {
			goto l0
		}
		t1 := -float32(3)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xtype_f64_value() float64 {
	var t0 float64
	_ = t0
	{
		t0 = float64(4)
		if int32(1) != 0 {
			goto l0
		}
		t1 := -float64(4)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_block_first(v0 int32) int32 {
	{
		t0 := v0
		if t0 != 0 {
			goto l0
		}
		return int32(2)
	}
l0:
	;
	return int32(3)
}
func (m *Module) Xas_block_mid(v0 int32) int32 {
	{
		m._dummy()
		t0 := v0
		if t0 != 0 {
			goto l0
		}
		return int32(2)
	}
l0:
	;
	return int32(3)
}
func (m *Module) Xas_block_last(v0 int32) {
	{
		m._dummy()
		m._dummy()
		t0 := v0
		if t0 != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_block_first_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(10)
		if t1 != 0 {
			goto l0
		}
		_ = int32(10)
		return int32(11)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_block_mid_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		t1 := v0
		t0 = int32(20)
		if t1 != 0 {
			goto l0
		}
		_ = int32(20)
		return int32(21)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_block_last_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		m._dummy()
		m._dummy()
		t1 := v0
		t0 = int32(11)
		if t1 != 0 {
			goto l0
		}
		t0 = int32(11)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_loop_first(v0 int32) int32 {
	{
		{
			t0 := v0
			if t0 != 0 {
				goto l0
			}
			return int32(2)
		}
	}
l0:
	;
	return int32(3)
}
func (m *Module) Xas_loop_mid(v0 int32) int32 {
	{
		{
			m._dummy()
			t0 := v0
			if t0 != 0 {
				goto l0
			}
			return int32(2)
		}
	}
l0:
	;
	return int32(4)
}
func (m *Module) Xas_loop_last(v0 int32) {
	{
		m._dummy()
		t0 := v0
		if t0 != 0 {
			return
		}
	}
}
func (m *Module) Xas_br_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(2) != 0 {
			goto l0
		}
		t0 = int32(1)
		goto l0
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_if_cond() {
	{
		if int32(1) != 0 {
			goto l0
		}
		if int32(1) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_if_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(2) != 0 {
			goto l0
		}
		t0 = int32(1)
		if int32(3) != 0 {
			goto l0
		}
		_ = int32(1)
		t0 = int32(4)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_if_value_cond(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(1)
		if t1 != 0 {
			goto l0
		}
		t0 = int32(2)
		if int32(1) != 0 {
			goto l0
		}
		_ = int32(2)
		t0 = int32(4)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_index() {
	{
		if int32(2) != 0 {
			goto l0
		}
		switch int32(1) {
		default:
			goto l0
		case 0:
			goto l0
		case 1:
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_table_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(2) != 0 {
			goto l0
		}
		t0 = int32(1)
		t0 = int32(1)
		t0 = int32(1)
		switch int32(3) {
		default:
			goto l0
		case 0:
			goto l0
		case 1:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_value_index() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(3) != 0 {
			goto l0
		}
		t0 = int32(2)
		t0 = int32(2)
		switch int32(1) {
		default:
			goto l0
		case 0:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_return_value() int64 {
	var t0 int64
	_ = t0
	{
		t0 = int64(1)
		if int32(2) != 0 {
			goto l0
		}
		return int64(1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_if_cond(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(1)
		if t1 != 0 {
			goto l0
		}
		var t2 int32
		_ = t2
		if int32(1) != 0 {
			t2 = int32(2)
		} else {
			t2 = int32(3)
		}
		t0 = t2
	}
l0:
	;
	return t0
}
func (m *Module) Xas_if_then(v0 int32, v1 int32) {
	{
		t0 := v0
		if t0 != 0 {
			t1 := v1
			if t1 != 0 {
				goto l0
			}
		} else {
			m._dummy()
		}
	}
l0:
}
func (m *Module) Xas_if_else(v0 int32, v1 int32) {
	{
		t0 := v0
		if t0 != 0 {
			m._dummy()
		} else {
			t1 := v1
			if t1 != 0 {
				goto l0
			}
		}
	}
l0:
}
func (m *Module) Xas_select_first(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(3)
		if int32(10) != 0 {
			goto l0
		}
		t1 := v0
		t2 := int32(2)
		if t1 != 0 {
			t2 = int32(3)
		}
		t0 = t2
	}
l0:
	;
	return t0
}
func (m *Module) Xas_select_second(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(3)
		if int32(10) != 0 {
			goto l0
		}
		t1 := v0
		t2 := int32(3)
		if t1 != 0 {
			t2 = int32(1)
		}
		t0 = t2
	}
l0:
	;
	return t0
}
func (m *Module) Xas_select_cond() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(3)
		if int32(10) != 0 {
			goto l0
		}
		t1 := int32(2)
		if int32(3) != 0 {
			t1 = int32(1)
		}
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) _f(v0 int32, v1 int32, v2 int32) int32 {
	return i32_const(-1)
}
func (m *Module) Xas_call_first() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(12)
		if int32(1) != 0 {
			goto l0
		}
		t1 := m._f(int32(12), int32(2), int32(3))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_call_mid() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(13)
		if int32(1) != 0 {
			goto l0
		}
		t1 := m._f(int32(1), int32(13), int32(3))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_call_last() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(14)
		if int32(1) != 0 {
			goto l0
		}
		t1 := m._f(int32(1), int32(2), int32(14))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) _func(v0 int32, v1 int32, v2 int32) int32 {
	t0 := v0
	return t0
}
func (m *Module) Xas_call_indirect_func() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(4)
		if int32(10) != 0 {
			goto l0
		}
		t1 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(4), int32(1), int32(2))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_call_indirect_first() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(4)
		if int32(10) != 0 {
			goto l0
		}
		t1 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(4), int32(2))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_call_indirect_mid() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(4)
		if int32(10) != 0 {
			goto l0
		}
		t1 := m.table[uint32(i32_const(0))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(4))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_call_indirect_last() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(4)
		if int32(10) != 0 {
			goto l0
		}
		t1 := m.table[uint32(int32(4))].(func(v0 int32, v1 int32, v2 int32) int32)(int32(1), int32(2), int32(3))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_local_set_value(v0 int32) int32 {
	var v1 int32
	_ = v1
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(17)
		if t1 != 0 {
			goto l0
		}
		v0 = int32(17)
		t0 = i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_local_tee_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(1)
		if t1 != 0 {
			goto l0
		}
		v0 = int32(1)
		return i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_global_set_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		t1 := v0
		t0 = int32(1)
		if t1 != 0 {
			goto l0
		}
		m._a = int32(1)
		return i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_load_address() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int32(binary.LittleEndian.Uint32(m.memory[uint32(int32(1)):]))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_loadN_address() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(30)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int32(int8(m.memory[uint32(int32(30))]))
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_store_address() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(30)
		if int32(1) != 0 {
			goto l0
		}
		binary.LittleEndian.PutUint32(m.memory[uint32(int32(30)):], uint32(int32(7)))
		t0 = i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_store_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(31)
		if int32(1) != 0 {
			goto l0
		}
		binary.LittleEndian.PutUint32(m.memory[uint32(int32(2)):], uint32(int32(31)))
		t0 = i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_storeN_address() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(32)
		if int32(1) != 0 {
			goto l0
		}
		m.memory[uint32(int32(32))] = byte(int32(7))
		t0 = i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_storeN_value() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(33)
		if int32(1) != 0 {
			goto l0
		}
		binary.LittleEndian.PutUint16(m.memory[uint32(int32(2)):], uint16(int32(33)))
		t0 = i32_const(-1)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_unary_operand() float64 {
	var t0 float64
	_ = t0
	{
		t0 = float64(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := -float64(1)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_binary_left() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int32(1) + int32(10)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_binary_right() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := int32(10) - int32(1)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_test_operand() int32 {
	var t0 int32
	_ = t0
	{
		t0 = i32_const(0)
		if int32(1) != 0 {
			goto l0
		}
		var t1 int32
		if i32_const(0) == 0 {
			t1 = 1
		}
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_compare_left() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		var t1 int32
		if uint32(int32(1)) <= uint32(int32(10)) {
			t1 = 1
		}
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_compare_right() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(42) != 0 {
			goto l0
		}
		var t1 int32
		if int32(10) != int32(1) {
			t1 = 1
		}
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_memory_grow_size() int32 {
	var t0 int32
	_ = t0
	{
		t0 = int32(1)
		if int32(1) != 0 {
			goto l0
		}
		t1 := memory_grow(&m.memory, int32(1), m.maxMem)
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xnested_block_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(16)
		}
		t3 := int32(4) + t1
		t0 = t3
	}
l0:
	;
	t4 := int32(1) + t0
	return t4
}
func (m *Module) Xnested_br_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(4)
		}
		t0 = t1
		goto l0
	}
l0:
	;
	t3 := int32(1) + t0
	return t3
}
func (m *Module) Xnested_br_if_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(4)
		}
		t0 = t1
		if int32(1) != 0 {
			goto l0
		}
		_ = t1
		t0 = int32(16)
	}
l0:
	;
	t3 := int32(1) + t0
	return t3
}
func (m *Module) Xnested_br_if_value_cond(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(1)
		}
		t0 = int32(4)
		if t1 != 0 {
			goto l0
		}
		_ = int32(4)
		t0 = int32(16)
	}
l0:
	;
	t3 := int32(1) + t0
	return t3
}
func (m *Module) Xnested_br_table_value(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(4)
		}
		t0 = t1
		switch int32(1) {
		default:
			goto l0
		}
	}
l0:
	;
	t3 := int32(1) + t0
	return t3
}
func (m *Module) Xnested_br_table_value_index(v0 int32) int32 {
	var t0 int32
	_ = t0
	{
		_ = int32(2)
		var t1 int32
		_ = t1
		{
			t2 := v0
			t0 = int32(8)
			if t2 != 0 {
				goto l0
			}
			_ = int32(8)
			t1 = int32(1)
		}
		t0 = int32(4)
		switch t1 {
		default:
			goto l0
		}
	}
l0:
	;
	t3 := int32(1) + t0
	return t3
}

func i32_const(x int32) int32 { return x }

func i64_const(x int64) int64 { return x }

func memory_grow(mem *[]byte, delta, max int32) int32 {
	buf := *mem
	len := len(buf)
	old := int32(len >> 16)
	if delta == 0 {
		return old
	}
	new := old + delta
	add := int(new)<<16 - len
	if new > max || add < 0 {
		return -1
	}
	*mem = append(buf, make([]byte, add)...)
	return old
}
