// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import "encoding/binary"

type Module struct {
	memory []byte
	maxMem int32
}

func New() *Module {
	m := &Module{}
	m.maxMem = 65536
	m.memory = make([]byte, 65536)
	return m
}
func (m *Module) Xas_block_value() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
	}
}
func (m *Module) Xas_loop_value() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
	}
}
func (m *Module) Xas_br_value() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
		goto l0
	}
l0:
}
func (m *Module) Xas_br_if_value() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
		if int32(1) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_if_value_cond() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
		if int32(6) != 0 {
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_br_table_value() {
	{
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
		switch int32(1) {
		default:
			goto l0
		}
	}
l0:
}
func (m *Module) Xas_return_value() {
	binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
	return
}
func (m *Module) Xas_if_then() {
	if int32(1) != 0 {
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
	}
}
func (m *Module) Xas_if_else() {
	if i32_const(0) != 0 {
	} else {
		binary.LittleEndian.PutUint32(m.memory[uint32(i32_const(0)):], uint32(int32(1)))
	}
}

func i32_const(x int32) int32 { return x }
