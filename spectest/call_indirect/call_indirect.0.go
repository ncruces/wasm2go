// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import (
	"encoding/binary"
	"math"
)

type Module struct {
	table    []any
	elements [][]any
	memory   []byte
	maxMem   int32
	_a       float64
}

func New() *Module {
	m := &Module{}
	m.table = make([]any, 29)
	m.maxMem = 65536
	m.memory = make([]byte, 65536)
	m.elements = [][]any{[]any{m._const_i32, m._const_i64, m._const_f32, m._const_f64, m._id_i32, m._id_i64, m._id_f32, m._id_f64, m._f32_i32, m._i32_i64, m._f64_f32, m._i64_f64, m.Xfac_i64, m.Xfib_i64, m.Xeven, m.Xodd, m.Xrunaway, m.Xmutual_runaway, m._mutual_runaway2, m._over_i32_duplicate, m._over_i64_duplicate, m._over_f32_duplicate, m._over_f64_duplicate, m.Xfac_i32, m.Xfac_f32, m.Xfac_f64, m.Xfib_i32, m.Xfib_f32, m.Xfib_f64}}
	copy(m.table[0:], m.elements[0])
	m._a = float64(10)
	return m
}
func (m *Module) _const_i32() int32 {
	return i32_const(306)
}
func (m *Module) _const_i64() int64 {
	return i64_const(356)
}
func (m *Module) _const_f32() float32 {
	return float32(3890)
}
func (m *Module) _const_f64() float64 {
	return float64(3940)
}
func (m *Module) _id_i32(v0 int32) int32 {
	t0 := v0
	return t0
}
func (m *Module) _id_i64(v0 int64) int64 {
	t0 := v0
	return t0
}
func (m *Module) _id_f32(v0 float32) float32 {
	t0 := v0
	return t0
}
func (m *Module) _id_f64(v0 float64) float64 {
	t0 := v0
	return t0
}
func (m *Module) _i32_i64(v0 int32, v1 int64) int64 {
	t0 := v1
	return t0
}
func (m *Module) _i64_f64(v0 int64, v1 float64) float64 {
	t0 := v1
	return t0
}
func (m *Module) _f32_i32(v0 float32, v1 int32) int32 {
	t0 := v1
	return t0
}
func (m *Module) _f64_f32(v0 float64, v1 float32) float32 {
	t0 := v1
	return t0
}
func (m *Module) _over_i32_duplicate(v0 int32) int32 {
	t0 := v0
	return t0
}
func (m *Module) _over_i64_duplicate(v0 int64) int64 {
	t0 := v0
	return t0
}
func (m *Module) _over_f32_duplicate(v0 float32) float32 {
	t0 := v0
	return t0
}
func (m *Module) _over_f64_duplicate(v0 float64) float64 {
	t0 := v0
	return t0
}
func (m *Module) f16() {
	m.table[uint32(i32_const(0))].(func())()
	m.table[uint32(i32_const(0))].(func(v0 int64))(i64_const(0))
	m.table[uint32(i32_const(0))].(func(v0 int64, v1 float64, v2 int32, v3 int64))(i64_const(0), float64(0), i32_const(0), i64_const(0))
	m.table[uint32(i32_const(0))].(func())()
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	var t1 int32
	if t0 == 0 {
		t1 = 1
	}
	_ = t1
	t2 := m.table[uint32(i32_const(0))].(func() int32)()
	var t3 int32
	if t2 == 0 {
		t3 = 1
	}
	_ = t3
	t4 := m.table[uint32(i32_const(0))].(func(v0 int64) int32)(i64_const(0))
	var t5 int32
	if t4 == 0 {
		t5 = 1
	}
	_ = t5
	t6 := m.table[uint32(i32_const(0))].(func(v0 int64, v1 float64, v2 int32, v3 int64) int32)(i64_const(0), float64(0), i32_const(0), i64_const(0))
	var t7 int32
	if t6 == 0 {
		t7 = 1
	}
	_ = t7
	t8 := m.table[uint32(i32_const(0))].(func(v0 int64) int64)(i64_const(0))
	var t9 int32
	if t8 == 0 {
		t9 = 1
	}
	_ = t9
}
func (m *Module) Xtype_i32() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	return t0
}
func (m *Module) Xtype_i64() int64 {
	t0 := m.table[uint32(int32(1))].(func() int64)()
	return t0
}
func (m *Module) Xtype_f32() float32 {
	t0 := m.table[uint32(int32(2))].(func() float32)()
	return t0
}
func (m *Module) Xtype_f64() float64 {
	t0 := m.table[uint32(int32(3))].(func() float64)()
	return t0
}
func (m *Module) Xtype_index() int64 {
	t0 := m.table[uint32(int32(5))].(func(v0 int64) int64)(int64(100))
	return t0
}
func (m *Module) Xtype_first_i32() int32 {
	t0 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(32))
	return t0
}
func (m *Module) Xtype_first_i64() int64 {
	t0 := m.table[uint32(int32(5))].(func(v0 int64) int64)(int64(64))
	return t0
}
func (m *Module) Xtype_first_f32() float32 {
	t0 := m.table[uint32(int32(6))].(func(v0 float32) float32)(float32(1.32))
	return t0
}
func (m *Module) Xtype_first_f64() float64 {
	t0 := m.table[uint32(int32(7))].(func(v0 float64) float64)(float64(1.64))
	return t0
}
func (m *Module) Xtype_second_i32() int32 {
	t0 := m.table[uint32(int32(8))].(func(v0 float32, v1 int32) int32)(float32(32.1), int32(32))
	return t0
}
func (m *Module) Xtype_second_i64() int64 {
	t0 := m.table[uint32(int32(9))].(func(v0 int32, v1 int64) int64)(int32(32), int64(64))
	return t0
}
func (m *Module) Xtype_second_f32() float32 {
	t0 := m.table[uint32(int32(10))].(func(v0 float64, v1 float32) float32)(float64(64), float32(32))
	return t0
}
func (m *Module) Xtype_second_f64() float64 {
	t0 := m.table[uint32(int32(11))].(func(v0 int64, v1 float64) float64)(int64(64), float64(64.1))
	return t0
}
func (m *Module) Xdispatch(v0 int32, v1 int64) int64 {
	t0 := v1
	t1 := v0
	t2 := m.table[uint32(t1)].(func(v0 int64) int64)(t0)
	return t2
}
func (m *Module) Xdispatch_structural_i64(v0 int32) int64 {
	t0 := v0
	t1 := m.table[uint32(t0)].(func(v0 int64) int64)(int64(9))
	return t1
}
func (m *Module) Xdispatch_structural_i32(v0 int32) int32 {
	t0 := v0
	t1 := m.table[uint32(t0)].(func(v0 int32) int32)(int32(9))
	return t1
}
func (m *Module) Xdispatch_structural_f32(v0 int32) float32 {
	t0 := v0
	t1 := m.table[uint32(t0)].(func(v0 float32) float32)(float32(9))
	return t1
}
func (m *Module) Xdispatch_structural_f64(v0 int32) float64 {
	t0 := v0
	t1 := m.table[uint32(t0)].(func(v0 float64) float64)(float64(9))
	return t1
}
func (m *Module) Xfac_i64(v0 int64) int64 {
	t0 := v0
	var t2 int64
	_ = t2
	if t0 == 0 {
		t2 = int64(1)
	} else {
		t3 := v0
		t4 := v0
		t5 := t4 - int64(1)
		t6 := m.table[uint32(int32(12))].(func(v0 int64) int64)(t5)
		t7 := t3 * t6
		t2 = t7
	}
	return t2
}
func (m *Module) Xfib_i64(v0 int64) int64 {
	t0 := v0
	var t2 int64
	_ = t2
	if uint64(t0) <= uint64(int64(1)) {
		t2 = int64(1)
	} else {
		t3 := v0
		t4 := t3 - int64(2)
		t5 := m.table[uint32(int32(13))].(func(v0 int64) int64)(t4)
		t6 := v0
		t7 := t6 - int64(1)
		t8 := m.table[uint32(int32(13))].(func(v0 int64) int64)(t7)
		t9 := t5 + t8
		t2 = t9
	}
	return t2
}
func (m *Module) Xfac_i32(v0 int32) int32 {
	t0 := v0
	var t2 int32
	_ = t2
	if t0 == 0 {
		t2 = int32(1)
	} else {
		t3 := v0
		t4 := v0
		t5 := t4 - int32(1)
		t6 := m.table[uint32(int32(23))].(func(v0 int32) int32)(t5)
		t7 := t3 * t6
		t2 = t7
	}
	return t2
}
func (m *Module) Xfac_f32(v0 float32) float32 {
	t0 := v0
	var t2 float32
	_ = t2
	if t0 == float32(0) {
		t2 = float32(1)
	} else {
		t3 := v0
		t4 := v0
		t5 := float32(t4 - float32(1))
		t6 := m.table[uint32(int32(24))].(func(v0 float32) float32)(t5)
		t7 := float32(t3 * t6)
		t2 = t7
	}
	return t2
}
func (m *Module) Xfac_f64(v0 float64) float64 {
	t0 := v0
	var t2 float64
	_ = t2
	if t0 == float64(0) {
		t2 = float64(1)
	} else {
		t3 := v0
		t4 := v0
		t5 := float64(t4 - float64(1))
		t6 := m.table[uint32(int32(25))].(func(v0 float64) float64)(t5)
		t7 := float64(t3 * t6)
		t2 = t7
	}
	return t2
}
func (m *Module) Xfib_i32(v0 int32) int32 {
	t0 := v0
	var t2 int32
	_ = t2
	if uint32(t0) <= uint32(int32(1)) {
		t2 = int32(1)
	} else {
		t3 := v0
		t4 := t3 - int32(2)
		t5 := m.table[uint32(int32(26))].(func(v0 int32) int32)(t4)
		t6 := v0
		t7 := t6 - int32(1)
		t8 := m.table[uint32(int32(26))].(func(v0 int32) int32)(t7)
		t9 := t5 + t8
		t2 = t9
	}
	return t2
}
func (m *Module) Xfib_f32(v0 float32) float32 {
	t0 := v0
	var t2 float32
	_ = t2
	if t0 <= float32(1) {
		t2 = float32(1)
	} else {
		t3 := v0
		t4 := float32(t3 - float32(2))
		t5 := m.table[uint32(int32(27))].(func(v0 float32) float32)(t4)
		t6 := v0
		t7 := float32(t6 - float32(1))
		t8 := m.table[uint32(int32(27))].(func(v0 float32) float32)(t7)
		t9 := float32(t5 + t8)
		t2 = t9
	}
	return t2
}
func (m *Module) Xfib_f64(v0 float64) float64 {
	t0 := v0
	var t2 float64
	_ = t2
	if t0 <= float64(1) {
		t2 = float64(1)
	} else {
		t3 := v0
		t4 := float64(t3 - float64(2))
		t5 := m.table[uint32(int32(28))].(func(v0 float64) float64)(t4)
		t6 := v0
		t7 := float64(t6 - float64(1))
		t8 := m.table[uint32(int32(28))].(func(v0 float64) float64)(t7)
		t9 := float64(t5 + t8)
		t2 = t9
	}
	return t2
}
func (m *Module) Xeven(v0 int32) int32 {
	t0 := v0
	var t2 int32
	_ = t2
	if t0 == 0 {
		t2 = int32(44)
	} else {
		t3 := v0
		t4 := t3 - int32(1)
		t5 := m.table[uint32(int32(15))].(func(v0 int32) int32)(t4)
		t2 = t5
	}
	return t2
}
func (m *Module) Xodd(v0 int32) int32 {
	t0 := v0
	var t2 int32
	_ = t2
	if t0 == 0 {
		t2 = int32(99)
	} else {
		t3 := v0
		t4 := t3 - int32(1)
		t5 := m.table[uint32(int32(14))].(func(v0 int32) int32)(t4)
		t2 = t5
	}
	return t2
}
func (m *Module) Xrunaway() {
	m.table[uint32(int32(16))].(func())()
}
func (m *Module) Xmutual_runaway() {
	m.table[uint32(int32(18))].(func())()
}
func (m *Module) _mutual_runaway2() {
	m.table[uint32(int32(17))].(func())()
}
func (m *Module) Xas_select_first() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	t1 := int32(2)
	if int32(3) != 0 {
		t1 = t0
	}
	return t1
}
func (m *Module) Xas_select_mid() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	t1 := t0
	if int32(3) != 0 {
		t1 = int32(2)
	}
	return t1
}
func (m *Module) Xas_select_last() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	t1 := int32(3)
	if t0 != 0 {
		t1 = int32(2)
	}
	return t1
}
func (m *Module) Xas_if_condition() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	var t1 int32
	_ = t1
	if t0 != 0 {
		t1 = int32(1)
	} else {
		t1 = int32(2)
	}
	return t1
}
func (m *Module) Xas_br_if_first() int64 {
	var t0 int64
	_ = t0
	{
		t1 := m.table[uint32(int32(1))].(func() int64)()
		t0 = t1
		if int32(2) != 0 {
			goto l0
		}
		t0 = t1
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_if_last() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(i32_const(0))].(func() int32)()
		t0 = int32(2)
		if t1 != 0 {
			goto l0
		}
		t0 = int32(2)
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_first() float32 {
	var t0 float32
	_ = t0
	{
		t1 := m.table[uint32(int32(2))].(func() float32)()
		t0 = t1
		t0 = t1
		switch int32(2) {
		default:
			goto l0
		case 0:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_br_table_last() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(i32_const(0))].(func() int32)()
		t0 = int32(2)
		t0 = int32(2)
		switch t1 {
		default:
			goto l0
		case 0:
			goto l0
		}
	}
l0:
	;
	return t0
}
func (m *Module) Xas_store_first() {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	binary.LittleEndian.PutUint32(m.memory[uint32(t0):], uint32(int32(1)))
}
func (m *Module) Xas_store_last() {
	t0 := m.table[uint32(int32(3))].(func() float64)()
	binary.LittleEndian.PutUint64(m.memory[uint32(int32(10)):], math.Float64bits(t0))
}
func (m *Module) Xas_memory_grow_value() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	t1 := memory_grow(&m.memory, t0, m.maxMem)
	return t1
}
func (m *Module) Xas_return_value() int32 {
	t0 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
	return t0
}
func (m *Module) Xas_drop_operand() {
	t0 := m.table[uint32(int32(5))].(func(v0 int64) int64)(int64(1))
	_ = t0
}
func (m *Module) Xas_br_value() float32 {
	var t0 float32
	_ = t0
	{
		t1 := m.table[uint32(int32(6))].(func(v0 float32) float32)(float32(1))
		t0 = t1
		goto l0
	}
l0:
	;
	return t0
}
func (m *Module) Xas_local_set_value() float64 {
	var v0 float64
	_ = v0
	t0 := m.table[uint32(int32(7))].(func(v0 float64) float64)(float64(1))
	v0 = t0
	t1 := v0
	return t1
}
func (m *Module) Xas_local_tee_value() float64 {
	var v0 float64
	_ = v0
	t0 := m.table[uint32(int32(7))].(func(v0 float64) float64)(float64(1))
	v0 = t0
	return t0
}
func (m *Module) Xas_global_set_value() float64 {
	t0 := m.table[uint32(int32(7))].(func(v0 float64) float64)(float64(1))
	m._a = t0
	t1 := m._a
	return t1
}
func (m *Module) Xas_load_operand() int32 {
	t0 := m.table[uint32(i32_const(0))].(func() int32)()
	t1 := int32(binary.LittleEndian.Uint32(m.memory[uint32(t0):]))
	return t1
}
func (m *Module) Xas_unary_operand() float32 {
	var t0 float32
	_ = t0
	{
		t1 := m.table[uint32(int32(6))].(func(v0 float32) float32)(float32(0))
		t2 := float32(math.Sqrt(float64(t1)))
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_binary_left() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		t2 := t1 + int32(10)
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_binary_right() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		t2 := int32(10) - t1
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_test_operand() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		var t2 int32
		if t1 == 0 {
			t2 = 1
		}
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_compare_left() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		var t2 int32
		if uint32(t1) <= uint32(int32(10)) {
			t2 = 1
		}
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_compare_right() int32 {
	var t0 int32
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		var t2 int32
		if int32(10) != t1 {
			t2 = 1
		}
		t0 = t2
	}
	return t0
}
func (m *Module) Xas_convert_operand() int64 {
	var t0 int64
	_ = t0
	{
		t1 := m.table[uint32(int32(4))].(func(v0 int32) int32)(int32(1))
		t2 := int64(t1)
		t0 = t2
	}
	return t0
}

func i32_const(x int32) int32 { return x }

func i64_const(x int64) int64 { return x }

func memory_grow(mem *[]byte, delta, max int32) int32 {
	buf := *mem
	len := len(buf)
	old := int32(len >> 16)
	if delta == 0 {
		return old
	}
	new := old + delta
	add := int(new)<<16 - len
	if new > max || add < 0 {
		return -1
	}
	*mem = append(buf, make([]byte, add)...)
	return old
}
