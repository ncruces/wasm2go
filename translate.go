package main

import (
	"bufio"
	"bytes"
	_ "embed"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"slices"
	"strconv"
	"strings"
)

//go:embed helpers/helpers.go
var helpersSrc string

type translator struct {
	in  *bufio.Reader
	out ast.File
	// Dependencies.
	packages set[string]
	helpers  set[string]
	// Sections.
	types     []funcType
	imports   []importDef
	functions []funcCompiler
	memory    *memoryDef
	table     *tableDef
	globals   []globalDef
	exports   map[string]export
	elements  []elemSegment
	start     uint64
	data      []dataSegment
}

func translate(r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.packages = set[string]{}
	t.helpers = set[string]{}

	// Load Wasm.
	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	if len(t.imports) > 0 {
		t.out.Decls = append(t.createHostInterfaces(), t.out.Decls...)
	}

	t.out.Decls = append([]ast.Decl{
		t.createModuleStruct(),
		t.createNewFunc()},
		t.out.Decls...)

	// Late binding of names.
	if t.out.Name == nil {
		t.out.Name = newID("wasm2go")
	}

	for i, fn := range t.functions {
		if fn.decl != nil && fn.decl.Name.Name == "" {
			fn.decl.Name.Name = "f" + strconv.Itoa(i)
		}
	}
	if t.memory != nil && t.memory.id.Name == "" {
		t.memory.id.Name = "memory"
	}
	if t.table != nil && t.table.id.Name == "" {
		t.table.id.Name = "table"
	}
	for i := range t.globals {
		if t.globals[i].id.Name == "" {
			t.globals[i].id.Name = "g" + strconv.Itoa(i)
		}
	}

	// Set imports.
	if len(t.packages) > 0 {
		specs := make([]ast.Spec, 0, len(t.data))
		for pkg := range t.packages {
			specs = append(specs, &ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"` + pkg + `"`},
			})
		}
		t.out.Decls = append([]ast.Decl{
			&ast.GenDecl{Tok: token.IMPORT, Specs: specs}},
			t.out.Decls...)
	}

	// Add helpers.
	fset := token.NewFileSet()
	if len(t.helpers) > 0 {
		f, err := parser.ParseFile(fset, "helpers.go", helpersSrc, 0)
		if err != nil {
			return err
		}
		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && t.helpers.has(fn.Name.Name) {
				t.out.Decls = append(t.out.Decls, decl)
			}
		}
	}

	// Add data segments.
	if len(t.data) > 0 {
		specs := make([]ast.Spec, len(t.data))
		for i, seg := range t.data {
			specs[i] = &ast.ValueSpec{
				Names: []*ast.Ident{dataId(i)},
				Values: []ast.Expr{&ast.BasicLit{
					Kind:  token.STRING,
					Value: strconv.Quote(string(seg.init)),
				}},
			}
		}
		t.out.Decls = append(t.out.Decls, &ast.GenDecl{Tok: token.CONST, Specs: specs})
	}

	// Print Go.
	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	err = format.Node(out, fset, &t.out)
	if err != nil {
		return err
	}
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	size, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionImport:
		return t.readImportSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionTable:
		return t.readTableSection()
	case sectionMemory:
		return t.readMemorySection()
	case sectionElement:
		return t.readElementSection()
	case sectionGlobal:
		return t.readGlobalSection()
	case sectionExport:
		return t.readExportSection()
	case sectionStart:
		return t.readStartSection()
	case sectionCode:
		return t.readCodeSection()
	case sectionData:
		return t.readDataSection()
	case sectionDataCount:
		return t.readDataCountSection()
	case sectionCustom:
		return t.readCustomSection(int(size))
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		t.types[i].params = buf.String()
		buf.Reset()

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		t.types[i].results = buf.String()
		buf.Reset()
	}
	return nil
}

func (t *translator) readImportSection() error {
	count, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	for range count {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		mod := buf.String()
		buf.Reset()

		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}
		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		name := buf.String()
		buf.Reset()

		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		switch importKind(kind) {
		case functionImport:
			index, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			typ := t.types[index]
			t.imports = append(t.imports, importDef{
				module: mod,
				name:   name,
				typ:    typ,
			})

			args := make([]ast.Expr, len(typ.params))
			for i := range typ.params {
				args[i] = localVar(i)
			}

			call := &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   &ast.SelectorExpr{X: newID("m"), Sel: newID(internal(mod))},
					Sel: newID(exported(name)),
				},
				Args: args,
			}

			var stmt ast.Stmt
			if len(typ.results) == 0 {
				stmt = &ast.ExprStmt{X: call}
			} else {
				stmt = &ast.ReturnStmt{Results: []ast.Expr{call}}
			}

			fn := funcCompiler{
				typ: typ,
				decl: &ast.FuncDecl{
					Name: &ast.Ident{},
					Recv: modRecvList,
					Type: typ.toAST(),
					Body: &ast.BlockStmt{
						List: []ast.Stmt{stmt},
					},
				},
			}
			t.functions = append(t.functions, fn)
			t.out.Decls = append(t.out.Decls, fn.decl)

		default:
			return fmt.Errorf("unsupported import kind: %x", kind)
		}
	}
	return nil
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	start := len(t.functions)
	t.functions = append(t.functions, make([]funcCompiler, numFuncs)...)
	for i := range numFuncs {
		i += uint64(start)
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.decl = &ast.FuncDecl{
			Name: &ast.Ident{},
			Recv: modRecvList,
			Type: fn.typ.toAST(),
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func (t *translator) readTableSection() error {
	numTabs, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	if numTabs == 0 {
		return nil
	}
	if numTabs > 1 {
		return fmt.Errorf("multiple tables not supported")
	}

	typ, err := t.in.ReadByte()
	if err != nil {
		return err
	}
	if typ != 0x70 { // funcref
		return fmt.Errorf("unsupported table type: %x", typ)
	}

	min, max, err := t.readLimits(65536) // 1 MiB
	if err != nil {
		return err
	}

	t.table = &tableDef{
		id:  &ast.Ident{},
		min: int(min),
		max: int(max),
	}
	return nil
}

func (t *translator) readMemorySection() error {
	numMems, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	if numMems == 0 {
		return nil
	}
	if numMems > 1 {
		return fmt.Errorf("multiple memories not supported")
	}

	min, max, err := t.readLimits(65536) // 4 GiB
	t.memory = &memoryDef{
		id:  &ast.Ident{},
		min: int(min),
		max: int(max),
	}
	return err
}

func (t *translator) readLimits(def uint64) (min, max uint64, err error) {
	flags, err := readLEB128(t.in)
	if err != nil {
		return
	}
	min, err = readLEB128(t.in)
	if err != nil {
		return
	}
	max = def
	if flags&1 == 1 {
		max, err = readLEB128(t.in)
	}
	return
}

func (t *translator) readGlobalSection() error {
	numGlobals, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.globals = make([]globalDef, numGlobals)
	for i := range t.globals {
		g := &t.globals[i]
		g.id = &ast.Ident{}

		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		g.typ = wasmType(typ)

		mut, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		g.mut = mut == 1

		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		switch opcode {
		case 0x41: // i32.const
			g.init, err = t.constI32()
			if err != nil {
				return err
			}
		case 0x42: // i64.const
			g.init, err = t.constI64()
			if err != nil {
				return err
			}
		case 0x43: // f32.const
			g.init, err = t.constF32()
			if err != nil {
				return err
			}
		case 0x44: // f64.const
			g.init, err = t.constF64()
			if err != nil {
				return err
			}
		case 0x23: // global.get
			g.init, err = t.globalGet()
			if err != nil {
				return err
			}
		default:
			return fmt.Errorf("unsupported global init opcode: %x", opcode)
		}

		if end, err := t.in.ReadByte(); err != nil {
			return err
		} else if end != 0x0b { // end
			return fmt.Errorf("expected end of init expr, got %x", end)
		}
	}
	return nil
}

func (t *translator) readElementSection() error {
	count, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.elements = make([]elemSegment, count)
	for i := range t.elements {
		if tag, err := readLEB128(t.in); err != nil {
			return err
		} else if tag == 1 {
			t.elements[i].passive = true
		} else if tag != 0 {
			return fmt.Errorf("unsupported element segment tag: %d", tag)
		}

		if !t.elements[i].passive {
			if opcode, err := t.in.ReadByte(); err != nil {
				return err
			} else if opcode != 0x41 { // i32.const
				return fmt.Errorf("unsupported offset expression opcode: %x", opcode)
			}
			offset, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			t.elements[i].offset = uint32(offset)
			if end, err := t.in.ReadByte(); err != nil {
				return err
			} else if end != 0x0b {
				return fmt.Errorf("expected end of expression, got %x", end)
			}
		}

		numElems, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		t.elements[i].init = make([]uint32, numElems)
		for j := range t.elements[i].init {
			idx, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			t.elements[i].init[j] = uint32(idx)
		}
	}
	return nil
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		name := buf.String()
		buf.Reset()

		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			decl := t.functions[index].decl
			decl.Name = ast.NewIdent(exported(name))
		case tableExport:
			id := "Table"
			if !strings.EqualFold(name, id) {
				id = exported(name)
			}
			t.table.id = ast.NewIdent(id)
		case memoryExport:
			id := "Memory"
			if !strings.EqualFold(name, id) {
				id = exported(name)
			}
			t.memory.id = ast.NewIdent(id)
		case globalExport:
			t.globals[index].id = ast.NewIdent(exported(name))
		}
	}
	return nil
}

func (t *translator) readStartSection() error {
	index, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	// Bitwise not makes the zero value useful (no start function).
	t.start = ^index
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		i += uint64(len(t.imports))
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(&t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn *funcCompiler) error {
	body := &ast.BlockStmt{}
	fn.translator = t
	fn.decl.Body = body
	fn.blocks = []funcBlock{{body: body}}

	numVars, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	// Declare local variables.
	// Parameters are predeclared locals.
	numLocals := len(fn.typ.params)
	for range numVars {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		ids := make([]*ast.Ident, n)
		rhs := make([]ast.Expr, n)
		for i := range int(n) {
			ids[i] = localVar(numLocals)
			rhs[i] = ids[i]
			numLocals++
		}
		body.List = append(body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: ids,
						Type:  wasmType(typ).Ident(),
					},
				},
			},
		}, &ast.AssignStmt{
			Lhs: slices.Repeat([]ast.Expr{newID("_")}, int(n)),
			Tok: token.ASSIGN,
			Rhs: rhs,
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := fn.blocks.top()

		switch opcode {
		case 0x00: // unreachable
			if !blk.unreachable {
				blk.unreachable = true
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun:  newID("panic"),
						Args: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: `"unreachable"`}},
					},
				})
			}

		case 0x01: // nop

		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			var cond ast.Expr
			if opcode == 0x04 { // if
				cond = fn.popCond()
			}

			// Declare block results outside the block.
			results := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				results[i] = fn.newTempVar()
				fn.emit(&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{results[i]},
								Type:  wasmType(t).Ident(),
							},
						},
					},
				})
			}

			childBlk := funcBlock{
				typ:      bt,
				results:  results,
				stackPos: len(fn.stack),
				body:     &ast.BlockStmt{},
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = childBlk.body

			case 0x03: // loop
				// Remember the loop start position.
				// Bitwise not makes the zero value useful (not a loop).
				childBlk.loopPos = ^len(blk.body.List)
				stmt = childBlk.body

			case 0x04: // if
				// We need to remember the if statement
				// so we can attach an else branch.
				childBlk.ifStmt = &ast.IfStmt{Cond: cond, Body: childBlk.body}
				stmt = childBlk.ifStmt
			}

			fn.emit(stmt)
			fn.blocks.append(childBlk)

		case 0x05: // else
			// Set the results of the if branch.
			fn.emit(blk.setResults(fn)...)
			fn.stack = fn.stack[:blk.stackPos]
			// Create a new block at the same level,
			// make it the else branch.
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.ifreachable = blk.unreachable
			blk.unreachable = false

		case 0x0b: // end
			if len(fn.blocks) == 1 { // End of the function body.
				if n := len(fn.typ.results); n > 0 && !blk.unreachable {
					ret := &ast.ReturnStmt{}
					ret.Results = make([]ast.Expr, n)
					copy(ret.Results, fn.stack.last(n))
					fn.emit(ret)
				}
				return nil
			}

			// Set block results, but push them again
			// so they're available to the parent block.
			fn.emit(blk.setResults(fn)...)
			fn.stack = fn.stack[:blk.stackPos]
			for _, tmp := range blk.results {
				fn.pushConst(tmp)
			}

			fn.blocks.pop()
			if blk.label != nil { // Add the label if requested.
				if blk.loopPos != 0 { // At the start for loops.
					parent := fn.blocks.top()
					parent.unreachable = blk.unreachable
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Stmt:  parent.body.List[^blk.loopPos],
						Label: blk.label,
					}
				} else { // At the end for other block types.
					fn.emit(&ast.LabeledStmt{
						Stmt:  &ast.EmptyStmt{},
						Label: blk.label,
					})
				}
			}
			if blk.ifreachable && blk.unreachable {
				fn.blocks.top().unreachable = true
			}

		case 0x0c: // br
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			fn.emit(fn.branch(n))
			blk.unreachable = true // After an uncoditional goto.

		case 0x0d: // br_if
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			// Conditional break.
			fn.emit(&ast.IfStmt{
				Cond: fn.popCond(),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{fn.branch(n)},
				},
			})

		case 0x0e: // br_table
			numTargets, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			targets := make([]uint64, numTargets)
			for i := range targets {
				target, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				targets[i] = target
			}
			defaultTarget, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			sw := &ast.SwitchStmt{Tag: fn.pop(), Body: &ast.BlockStmt{
				List: []ast.Stmt{&ast.CaseClause{
					Body: []ast.Stmt{fn.branch(defaultTarget)},
				}},
			}}
			for i, target := range targets {
				sw.Body.List = append(sw.Body.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(i)}},
					Body: []ast.Stmt{fn.branch(target)},
				})
			}
			fn.emit(sw)
			blk.unreachable = true // After switch.

		case 0x10: // call
			index, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			target := &t.functions[index]

			args := make([]ast.Expr, len(target.typ.params))
			for i := len(args) - 1; i >= 0; i-- {
				args[i] = fn.pop()
			}

			call := &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("m"),
					Sel: target.decl.Name,
				},
				Args: args,
			}

			if len(target.typ.results) == 0 {
				fn.emit(&ast.ExprStmt{X: call})
				break
			}

			lhs := make([]ast.Expr, len(target.typ.results))
			for i := range lhs {
				lhs[i] = fn.newTempVar()
			}
			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: lhs,
				Rhs: []ast.Expr{call},
			})
			for _, tmp := range lhs {
				fn.pushConst(tmp)
			}

		case 0x11: // call_indirect
			typeIdx, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			tableIdx, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			if tableIdx != 0 {
				return fmt.Errorf("unsupported table index: %d", tableIdx)
			}

			idx := fn.pop()
			typ := t.types[typeIdx]
			args := make([]ast.Expr, len(typ.params))
			for i := len(args) - 1; i >= 0; i-- {
				args[i] = fn.pop()
			}

			call := &ast.CallExpr{
				Fun: &ast.TypeAssertExpr{
					X: &ast.IndexExpr{
						X:     &ast.SelectorExpr{X: newID("m"), Sel: t.table.id},
						Index: convert(idx, "uint32"),
					},
					Type: typ.toAST(),
				},
				Args: args,
			}

			if len(typ.results) == 0 {
				fn.emit(&ast.ExprStmt{X: call})
				break
			}

			lhs := make([]ast.Expr, len(typ.results))
			for i := range lhs {
				lhs[i] = fn.newTempVar()
			}
			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: lhs,
				Rhs: []ast.Expr{call},
			})
			for _, tmp := range lhs {
				fn.pushConst(tmp)
			}

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if n := len(fn.typ.results); n > 0 {
				ret.Results = make([]ast.Expr, n)
				copy(ret.Results, fn.stack.last(n))
			}
			fn.emit(ret)
			blk.unreachable = true // After an uncoditional return.

		case 0x1a: // drop
			fn.emit(&ast.AssignStmt{
				Tok: token.ASSIGN,
				Lhs: []ast.Expr{newID("_")},
				Rhs: []ast.Expr{fn.pop()},
			})

		case 0x1b: // select
			cond := fn.popCond()
			tmp := fn.newTempVar()
			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{tmp},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{&ast.AssignStmt{
						Tok: token.ASSIGN,
						Lhs: []ast.Expr{tmp},
						Rhs: []ast.Expr{fn.pop()},
					}}},
			})
			fn.pushConst(tmp)

		case 0x1c: // select (typed)
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			for range n {
				if _, err := t.in.ReadByte(); err != nil {
					return err
				}
			}

			cond := fn.popCond()
			if n == 0 {
				fn.emit(&ast.IfStmt{
					Cond: cond,
					Body: &ast.BlockStmt{},
				})
				break
			}

			vf := make([]ast.Expr, n)
			for i := int(n) - 1; i >= 0; i-- {
				vf[i] = fn.pop()
			}

			vt := make([]ast.Expr, n)
			for i := int(n) - 1; i >= 0; i-- {
				vt[i] = fn.pop()
			}

			tmp := make([]ast.Expr, n)
			for i := range tmp {
				tmp[i] = fn.newTempVar()
			}

			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: tmp,
				Rhs: vf,
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{&ast.AssignStmt{
						Tok: token.ASSIGN,
						Lhs: tmp,
						Rhs: vt,
					}}},
			})

			for _, tmp := range tmp {
				fn.pushConst(tmp)
			}

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(localVar(i))

		case 0x21: // local.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{fn.pop()},
				Tok: token.ASSIGN,
			})

		case 0x22: // local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			tmp := fn.pop()
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{tmp},
				Tok: token.ASSIGN,
			})
			fn.pushConst(tmp)

		case 0x23: // global.get
			e, err := t.globalGet()
			if err != nil {
				return err
			}
			fn.push(e)

		case 0x24: // global.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{&ast.SelectorExpr{
					X:   newID("m"),
					Sel: t.globals[i].id,
				}},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{fn.pop()},
			})

		case 0x2c, 0x2d, 0x30, 0x31: // load8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			idx := fn.memory8(offset)
			switch opcode {
			case 0x2c: // i32.load8_s
				fn.push(convert(idx, "int8", "int32"))
			case 0x2d: // i32.load8_u
				fn.push(convert(idx, "int32"))
			case 0x30: // i64.load8_s
				fn.push(convert(idx, "int8", "int64"))
			case 0x31: // i64.load8_u
				fn.push(convert(idx, "int64"))
			}

		case 0x28, 0x29, 0x2a, 0x2b, 0x2e, 0x2f, 0x32, 0x33, 0x34, 0x35: // load
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x28: // i32.load
				fn.push(convert(load("32", idx), "int32"))
			case 0x29: // i64.load
				fn.push(convert(load("64", idx), "int64"))
			case 0x2a: // f32.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32frombits")},
					Args: []ast.Expr{load("32", idx)},
				})
			case 0x2b: // f64.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64frombits")},
					Args: []ast.Expr{load("64", idx)},
				})
			case 0x2e: // i32.load16_s
				fn.push(convert(load("16", idx), "int16", "int32"))
			case 0x2f: // i32.load16_u
				fn.push(convert(load("16", idx), "int32"))
			case 0x32: // i64.load16_s
				fn.push(convert(load("16", idx), "int16", "int64"))
			case 0x33: // i64.load16_u
				fn.push(convert(load("16", idx), "int64"))
			case 0x34: // i64.load32_s
				fn.push(convert(load("32", idx), "int32", "int64"))
			case 0x35: // i64.load32_u
				fn.push(convert(load("32", idx), "int64"))
			}

		case 0x3a, 0x3c: // store8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			val := fn.pop()
			idx := fn.memory8(offset)
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{idx},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{convert(val, "byte")},
			})

		case 0x36, 0x37, 0x38, 0x39, 0x3b, 0x3d, 0x3e: // store
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			val := fn.pop()
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x36: // i32.store
				fn.emit(store("32", idx, convert(val, "uint32")))
			case 0x37: // i64.store
				fn.emit(store("64", idx, convert(val, "uint64")))
			case 0x38: // f32.store
				fn.packages.add("math")
				fn.emit(store("32", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32bits")},
					Args: []ast.Expr{val},
				}))
			case 0x39: // f64.store
				fn.packages.add("math")
				fn.emit(store("64", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64bits")},
					Args: []ast.Expr{val},
				}))
			case 0x3b: // i32.store16
				fn.emit(store("16", idx, convert(val, "uint16")))
			case 0x3d: // i64.store16
				fn.emit(store("16", idx, convert(val, "uint16")))
			case 0x3e: // i64.store32
				fn.emit(store("32", idx, convert(val, "uint32")))
			}

		case 0x3f: // memory.size
			_, _ = t.in.ReadByte() // reserved
			fn.push(convert(
				&ast.BinaryExpr{
					X: &ast.CallExpr{
						Fun: newID("len"),
						Args: []ast.Expr{&ast.SelectorExpr{
							X:   newID("m"),
							Sel: fn.memory.id,
						}},
					},
					Op: token.SHR,
					Y:  &ast.BasicLit{Kind: token.INT, Value: "16"},
				}, "int32"))

		case 0x40: // memory.grow
			_, err := t.in.ReadByte() // reserved
			if err != nil {
				return err
			}
			fn.helpers.add("memory_grow")
			fn.push(&ast.CallExpr{
				Fun: newID("memory_grow"),
				Args: []ast.Expr{
					&ast.UnaryExpr{
						Op: token.AND,
						X:  &ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
					},
					fn.pop(),
					&ast.SelectorExpr{
						X:   newID("m"),
						Sel: memoryMaxLenId(fn.memory.id),
					},
				},
			})

		case 0x41: // i32.const
			e, err := t.constI32()
			if err != nil {
				return err
			}
			fn.pushConst(e)

		case 0x42: // i64.const
			e, err := t.constI64()
			if err != nil {
				return err
			}
			fn.pushConst(e)

		case 0x43: // f32.const
			e, err := t.constF32()
			if err != nil {
				return err
			}
			fn.pushConst(e)

		case 0x44: // f64.const
			e, err := t.constF64()
			if err != nil {
				return err
			}
			fn.pushConst(e)

		case 0x45: // i32.eqz
			fn.eqzOp()
		case 0x46: // i32.eq
			fn.cmpOp(token.EQL)
		case 0x47: // i32.ne
			fn.cmpOp(token.NEQ)
		case 0x48: // i32.lt_s
			fn.cmpOp(token.LSS)
		case 0x49: // i32.lt_u
			fn.cmpOpU32(token.LSS)
		case 0x4a: // i32.gt_s
			fn.cmpOp(token.GTR)
		case 0x4b: // i32.gt_u
			fn.cmpOpU32(token.GTR)
		case 0x4c: // i32.le_s
			fn.cmpOp(token.LEQ)
		case 0x4d: // i32.le_u
			fn.cmpOpU32(token.LEQ)
		case 0x4e: // i32.ge_s
			fn.cmpOp(token.GEQ)
		case 0x4f: // i32.ge_u
			fn.cmpOpU32(token.GEQ)

		case 0x50: // i64.eqz
			fn.eqzOp()
		case 0x51: // i64.eq
			fn.cmpOp(token.EQL)
		case 0x52: // i64.ne
			fn.cmpOp(token.NEQ)
		case 0x53: // i64.lt_s
			fn.cmpOp(token.LSS)
		case 0x54: // i64.lt_u
			fn.cmpOpU64(token.LSS)
		case 0x55: // i64.gt_s
			fn.cmpOp(token.GTR)
		case 0x56: // i64.gt_u
			fn.cmpOpU64(token.GTR)
		case 0x57: // i64.le_s
			fn.cmpOp(token.LEQ)
		case 0x58: // i64.le_u
			fn.cmpOpU64(token.LEQ)
		case 0x59: // i64.ge_s
			fn.cmpOp(token.GEQ)
		case 0x5a: // i64.ge_u
			fn.cmpOpU64(token.GEQ)

		case 0x5b: // f32.eq
			fn.cmpOp(token.EQL)
		case 0x5c: // f32.ne
			fn.cmpOp(token.NEQ)
		case 0x5d: // f32.lt
			fn.cmpOp(token.LSS)
		case 0x5e: // f32.gt
			fn.cmpOp(token.GTR)
		case 0x5f: // f32.le
			fn.cmpOp(token.LEQ)
		case 0x60: // f32.ge
			fn.cmpOp(token.GEQ)

		case 0x61: // f64.eq
			fn.cmpOp(token.EQL)
		case 0x62: // f64.ne
			fn.cmpOp(token.NEQ)
		case 0x63: // f64.lt
			fn.cmpOp(token.LSS)
		case 0x64: // f64.gt
			fn.cmpOp(token.GTR)
		case 0x65: // f64.le
			fn.cmpOp(token.LEQ)
		case 0x66: // f64.ge
			fn.cmpOp(token.GEQ)

		case 0x67: // i32.clz
			fn.bitOp("LeadingZeros32")
		case 0x68: // i32.ctz
			fn.bitOp("TrailingZeros32")
		case 0x69: // i32.popcnt
			fn.bitOp("OnesCount32")
		case 0x6a: // i32.add
			fn.binOp(token.ADD)
		case 0x6b: // i32.sub
			fn.binOp(token.SUB)
		case 0x6c: // i32.mul
			fn.binOp(token.MUL)
		case 0x6d: // i32.div_s
			fn.binHelper("i32_div_s", "math")
		case 0x6e: // i32.div_u
			fn.binOpU32(token.QUO)
		case 0x6f: // i32.rem_s
			fn.binOp(token.REM)
		case 0x70: // i32.rem_u
			fn.binOpU32(token.REM)
		case 0x71: // i32.and
			fn.binOp(token.AND)
		case 0x72: // i32.or
			fn.binOp(token.OR)
		case 0x73: // i32.xor
			fn.binOp(token.XOR)
		case 0x74: // i32.shl
			fn.binHelper("i32_shl")
		case 0x75: // i32.shr_s
			fn.binHelper("i32_shr_s")
		case 0x76: // i32.shr_u
			fn.binHelper("i32_shr_u")
		case 0x77: // i32.rotl
			fn.binHelper("i32_rotl", "math/bits")
		case 0x78: // i32.rotr
			fn.binHelper("i32_rotr", "math/bits")

		case 0x79: // i64.clz
			fn.bitOp("LeadingZeros64")
		case 0x7a: // i64.ctz
			fn.bitOp("TrailingZeros64")
		case 0x7b: // i64.popcnt
			fn.bitOp("OnesCount64")
		case 0x7c: // i64.add
			fn.binOp(token.ADD)
		case 0x7d: // i64.sub
			fn.binOp(token.SUB)
		case 0x7e: // i64.mul
			fn.binOp(token.MUL)
		case 0x7f: // i64.div_s
			fn.binHelper("i64_div_s", "math")
		case 0x80: // i64.div_u
			fn.binOpU64(token.QUO)
		case 0x81: // i64.rem_s
			fn.binOp(token.REM)
		case 0x82: // i64.rem_u
			fn.binOpU64(token.REM)
		case 0x83: // i64.and
			fn.binOp(token.AND)
		case 0x84: // i64.or
			fn.binOp(token.OR)
		case 0x85: // i64.xor
			fn.binOp(token.XOR)
		case 0x86: // i64.shl
			fn.binHelper("i64_shl")
		case 0x87: // i64.shr_s
			fn.binHelper("i64_shr_s")
		case 0x88: // i64.shr_u
			fn.binHelper("i64_shr_u")
		case 0x89: // i64.rotl
			fn.binHelper("i64_rotl", "math/bits")
		case 0x8a: // i64.rotr
			fn.binHelper("i64_rotr", "math/bits")

		case 0x8b: // f32.abs
			fn.uniMath32("Abs")
		case 0x8c: // f32.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x8d: // f32.ceil
			fn.uniMath32("Ceil")
		case 0x8e: // f32.floor
			fn.uniMath32("Floor")
		case 0x8f: // f32.trunc
			fn.uniMath32("Trunc")
		case 0x90: // f32.nearest
			fn.uniMath32("RoundToEven")
		case 0x91: // f32.sqrt
			fn.uniMath32("Sqrt")
		case 0x92: // f32.add
			fn.binOpF32(token.ADD)
		case 0x93: // f32.sub
			fn.binOpF32(token.SUB)
		case 0x94: // f32.mul
			fn.binOpF32(token.MUL)
		case 0x95: // f32.div
			fn.binOpF32(token.QUO) // go.dev/issue/43577
		case 0x96: // f32.min
			fn.binBuiltin("min")
		case 0x97: // f32.max
			fn.binBuiltin("max")
		case 0x98: // f32.copysign
			fn.binMath32("Copysign")

		case 0x99: // f64.abs
			fn.uniMath64("Abs")
		case 0x9a: // f64.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x9b: // f64.ceil
			fn.uniMath64("Ceil")
		case 0x9c: // f64.floor
			fn.uniMath64("Floor")
		case 0x9d: // f64.trunc
			fn.uniMath64("Trunc")
		case 0x9e: // f64.nearest
			fn.uniMath64("RoundToEven")
		case 0x9f: // f64.sqrt
			fn.uniMath64("Sqrt")
		case 0xa0: // f64.add
			fn.binOpF64(token.ADD)
		case 0xa1: // f64.sub
			fn.binOpF64(token.SUB)
		case 0xa2: // f64.mul
			fn.binOpF64(token.MUL)
		case 0xa3: // f64.div
			fn.binOpF64(token.QUO) // go.dev/issue/43577
		case 0xa4: // f64.min
			fn.binBuiltin("min")
		case 0xa5: // f64.max
			fn.binBuiltin("max")
		case 0xa6: // f64.copysign
			fn.binMath64("Copysign")

		case 0xa7: // i32.wrap_i64
			fn.convert("int32")

		case 0xa8: // i32.trunc_f32_s
			fn.uniHelper("i32_trunc_f32_s")
		case 0xa9: // i32.trunc_f32_u
			fn.uniHelper("i32_trunc_f32_u")
		case 0xaa: // i32.trunc_f64_s
			fn.uniHelper("i32_trunc_f64_s")
		case 0xab: // i32.trunc_f64_u
			fn.uniHelper("i32_trunc_f64_u")

		case 0xac: // i64.extend_i32_s
			fn.convert("int64")
		case 0xad: // i64.extend_i32_u
			fn.convert("uint32", "int64")

		case 0xae: // i64.trunc_f32_s
			fn.uniHelper("i64_trunc_f32_s")
		case 0xaf: // i64.trunc_f32_u
			fn.uniHelper("i64_trunc_f32_u")
		case 0xb0: // i64.trunc_f64_s
			fn.uniHelper("i64_trunc_f64_s")
		case 0xb1: // i64.trunc_f64_u
			fn.uniHelper("i64_trunc_f64_u")

		case 0xb2: // f32.convert_i32_s
			fn.convert("float32")
		case 0xb3: // f32.convert_i32_u
			fn.convert("uint32", "float32")
		case 0xb4: // f32.convert_i64_s
			fn.convert("float32")
		case 0xb5: // f32.convert_i64_u
			fn.convert("uint64", "float32")
		case 0xb6: // f32.demote_f64
			fn.convert("float32")

		case 0xb7: // f64.convert_i32_s
			fn.convert("float64")
		case 0xb8: // f64.convert_i32_u
			fn.convert("uint32", "float64")
		case 0xb9: // f64.convert_i64_s
			fn.convert("float64")
		case 0xba: // f64.convert_i64_u
			fn.convert("uint64", "float64")
		case 0xbb: // f64.promote_f32
			fn.convert("float64")

		case 0xbc: // i32.reinterpret_f32
			fn.float32bits()
		case 0xbd: // i64.reinterpret_f64
			fn.float64bits()
		case 0xbe: // f32.reinterpret_i32
			fn.float32frombits()
		case 0xbf: // f64.reinterpret_i64
			fn.float64frombits()

		case 0xc0: // i32.extend8_s
			fn.convert("int8", "int32")
		case 0xc1: // i32.extend16_s
			fn.convert("int16", "int32")
		case 0xc2: // i64.extend8_s
			fn.convert("int8", "int64")
		case 0xc3: // i64.extend16_s
			fn.convert("int16", "int64")
		case 0xc4: // i64.extend32_s
			fn.convert("int32", "int64")

		case 0xfc:
			code, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			switch code {
			case 0x00: // i32.trunc_sat_f32_s
				fn.uniHelper("i32_trunc_sat_f32_s")
			case 0x01: // i32.trunc_sat_f32_u
				fn.uniHelper("i32_trunc_sat_f32_u")
			case 0x02: // i32.trunc_sat_f64_s
				fn.uniHelper("i32_trunc_sat_f64_s")
			case 0x03: // i32.trunc_sat_f64_u
				fn.uniHelper("i32_trunc_sat_f64_u")
			case 0x04: // i64.trunc_sat_f32_s
				fn.uniHelper("i64_trunc_sat_f32_s")
			case 0x05: // i64.trunc_sat_f32_u
				fn.uniHelper("i64_trunc_sat_f32_u")
			case 0x06: // i64.trunc_sat_f64_s
				fn.uniHelper("i64_trunc_sat_f64_s")
			case 0x07: // i64.trunc_sat_f64_u
				fn.uniHelper("i64_trunc_sat_f64_u")

			case 0x08: // memory.init
				i, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				_, err = readLEB128(t.in)
				if err != nil {
					return err
				}

				fn.helpers.add("memory_init")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("memory_init"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
							dataId(i), fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x09: // data.drop
				// No-op since data segments are constants.
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}

			case 0x0a: // memory.copy
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				_, err = readLEB128(t.in)
				if err != nil {
					return err
				}
				fn.helpers.add("memory_copy")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("memory_copy"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x0b: // memory.fill
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				fn.helpers.add("memory_fill")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("memory_fill"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x0c: // table.init
				elemIdx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				tableIdx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				if tableIdx != 0 {
					return fmt.Errorf("unsupported table index: %d", tableIdx)
				}
				fn.helpers.add("table_init")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("table_init"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: t.table.id},
							&ast.IndexExpr{
								X:     &ast.SelectorExpr{X: newID("m"), Sel: newID("elements")},
								Index: &ast.BasicLit{Kind: token.INT, Value: strconv.FormatUint(elemIdx, 10)},
							},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x0d: // elem.drop
				// No-op since element segments are static.
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}

			case 0x0e: // table.copy
				dstIdx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				srcIdx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				if dstIdx != 0 || srcIdx != 0 {
					return fmt.Errorf("unsupported table index")
				}
				fn.helpers.add("table_copy")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("table_copy"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: t.table.id},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x10: // table.size
				idx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				if idx != 0 {
					return fmt.Errorf("unsupported table index")
				}
				fn.push(convert(&ast.CallExpr{
					Fun: newID("len"),
					Args: []ast.Expr{&ast.SelectorExpr{
						X:   newID("m"),
						Sel: t.table.id,
					}},
				}, "int32"))

			default:
				return fmt.Errorf("unsupported opcode: 0xfc %02x", code)
			}

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func (t *translator) readDataCountSection() error {
	_, err := readLEB128(t.in)
	return err
}

func (t *translator) readDataSection() error {
	count, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.data = make([]dataSegment, count)
	for i := range t.data {
		if tag, err := readLEB128(t.in); err != nil {
			return err
		} else if tag == 1 {
			t.data[i].passive = true
		} else if tag != 0 {
			return fmt.Errorf("unsupported data segment tag: %d", tag)
		}

		if !t.data[i].passive {
			if opcode, err := t.in.ReadByte(); err != nil {
				return err
			} else if opcode != 0x41 { // i32.const
				return fmt.Errorf("unsupported offset expression opcode: %x", opcode)
			}
			offset, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			t.data[i].offset = uint32(offset)
			if end, err := t.in.ReadByte(); err != nil {
				return err
			} else if end != 0x0b {
				return fmt.Errorf("expected end of expression, got %x", end)
			}
		}

		numElems, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		t.data[i].init = make([]byte, numElems)
		if _, err := io.ReadFull(t.in, t.data[i].init); err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCustomSection(size int) error {
	data := make([]byte, size)
	if _, err := io.ReadFull(t.in, data); err != nil {
		return err
	}

	r := bytes.NewReader(data)
	n, err := readLEB128(r)
	if err != nil {
		return err
	}
	var buf strings.Builder
	if _, err := io.CopyN(&buf, r, int64(n)); err != nil {
		return err
	}
	if buf.String() == "name" {
		return t.readNameSection(r)
	}
	return nil
}

func (t *translator) readNameSection(r *bytes.Reader) error {
	for r.Len() > 0 {
		kind, err := r.ReadByte()
		if err != nil {
			return err
		}
		size, err := readLEB128(r)
		if err != nil {
			return err
		}

		switch nameSubsection(kind) {
		case nameModule:
			n, err := readLEB128(r)
			if err != nil {
				return err
			}
			var buf strings.Builder
			if _, err := io.CopyN(&buf, r, int64(n)); err != nil {
				return err
			}
			name := buf.String()
			buf.Reset()
			mangle(&buf, string(name))
			t.out.Name = ast.NewIdent(buf.String())

		case nameFunction, nameGlobal:
			count, err := readLEB128(r)
			if err != nil {
				return err
			}
			for range count {
				index, err := readLEB128(r)
				if err != nil {
					return err
				}
				n, err := readLEB128(r)
				if err != nil {
					return err
				}
				var buf strings.Builder
				if _, err := io.CopyN(&buf, r, int64(n)); err != nil {
					return err
				}

				var id *ast.Ident
				switch nameSubsection(kind) {
				case nameFunction:
					if int(index) < len(t.functions) {
						id = t.functions[index].decl.Name
					}
				case nameGlobal:
					if int(index) < len(t.globals) {
						id = t.globals[index].id
					}
				}
				if id != nil && id.Name == "" {
					id.Name = internal(buf.String())
				}
			}

		default:
			_, err := r.Seek(int64(size), io.SeekCurrent)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
