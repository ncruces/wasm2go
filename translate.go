package main

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"slices"
	"strconv"
)

var (
	int32Ident  = ast.NewIdent("int32")
	uint32Ident = ast.NewIdent("uint32")
	modTypIdent = ast.NewIdent("Module")
	modVarIdent = ast.NewIdent("m")
	modRecvList = &ast.FieldList{List: []*ast.Field{{
		Names: []*ast.Ident{modVarIdent},
		Type:  modTypIdent,
	}}}
)

type translator struct {
	in  *bufio.Reader
	out ast.File

	types     []funcType
	functions []funcRef
	exports   map[string]export
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = ast.NewIdent(name)
	t.out.Decls = append(t.out.Decls, createModuleStruct())

	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, token.NewFileSet(), &t.out)
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	_, err = readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionExport:
		return t.readExportSection()
	case sectionCode:
		return t.readCodeSection()
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

type wasmType byte

const (
	i32 wasmType = 127 - iota
	i64
	f32
	f64
)

func (t wasmType) String() string {
	switch t {
	case i32:
		return "int32"
	case i64:
		return "int64"
	case f32:
		return "float32"
	case f64:
		return "float64"
	}
	panic(fmt.Sprintf("unsupported type: %x", byte(t)))
}

type funcType struct {
	params  string // wasmType of parameters
	results string // wasmType of results
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var types []byte
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].params = string(types)

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].results = string(types)
	}
	return nil
}

type funcRef struct {
	typ  funcType
	decl *ast.FuncDecl

	stack  []*ast.Expr
	blocks []block
	labels int
	temps  int
}

type block struct {
	typ         funcType
	body        *ast.BlockStmt
	ifStmt      *ast.IfStmt
	results     []*ast.Ident
	label       string
	loopPos     int
	unreachable bool
}

func (f *funcRef) push(expr ast.Expr) {
	f.stack = append(f.stack, &expr)
}

func (f *funcRef) pushTemp(expr ast.Expr) {
	id := f.makeTempVar()
	blk := &f.blocks[len(f.blocks)-1]
	blk.body.List = append(blk.body.List, &ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{id},
		Rhs: []ast.Expr{expr},
	})
	f.push(id)
}

func (f *funcRef) pop() ast.Expr {
	expr := *f.stack[len(f.stack)-1]
	f.stack = f.stack[:len(f.stack)-1]
	return expr
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.functions = make([]funcRef, numFuncs)
	for i := range t.functions {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.decl = &ast.FuncDecl{
			Type: makeFuncType(fn.typ),
			Recv: modRecvList,
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func makeFuncType(t funcType) *ast.FuncType {
	return &ast.FuncType{
		Params:  makeParamsList(t.params),
		Results: makeResultsList(t.results),
	}
}

func makeParamsList(types string) *ast.FieldList {
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(local(i))},
			Type:  ast.NewIdent(wasmType(t).String()),
		}
	}
	return &ast.FieldList{List: list}
}

func makeResultsList(types string) *ast.FieldList {
	if len(types) == 0 {
		return nil
	}
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{Type: ast.NewIdent(wasmType(t).String())}
	}
	return &ast.FieldList{List: list}
}

type exportKind byte

const (
	functionExport exportKind = iota
	tableExport
	memoryExport
	globalExport
)

type export struct {
	kind  exportKind
	index int
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var names []byte
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		names = slices.Grow(names[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, names)
		if err != nil {
			return err
		}

		name := string(names)
		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			if decl := t.functions[index].decl; decl.Name == nil {
				decl.Name = ast.NewIdent(exported(name))
			}
		}
	}
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn funcRef) error {
	fn.decl.Body = &ast.BlockStmt{}
	fn.blocks = []block{{body: fn.decl.Body}}

	numLocals, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	localIndex := len(fn.typ.params)
	for range numLocals {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		names := make([]*ast.Ident, int(n))
		for j := range int(n) {
			names[j] = ast.NewIdent(local(localIndex))
			localIndex++
		}
		fn.decl.Body.List = append(fn.decl.Body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: names,
						Type:  ast.NewIdent(wasmType(typ).String()),
					},
				},
			},
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := &fn.blocks[len(fn.blocks)-1]

		switch opcode {
		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			parent := &fn.blocks[len(fn.blocks)-1]
			resultVars := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				resultVars[i] = fn.makeTempVar()
				parent.body.List = append(parent.body.List, &ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{resultVars[i]},
								Type:  ast.NewIdent(wasmType(t).String()),
							},
						},
					},
				})
			}

			b := block{
				typ:     bt,
				body:    &ast.BlockStmt{},
				results: resultVars,
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = b.body

			case 0x03: // loop
				b.loopPos = ^len(parent.body.List)
				stmt = b.body

			case 0x04: // if
				cond := fn.pop()
				b.ifStmt = &ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X:  cond,
						Op: token.NEQ,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
					},
					Body: b.body,
				}
				stmt = b.ifStmt
			}

			blk.body.List = append(blk.body.List, stmt)
			fn.blocks = append(fn.blocks, b)

		case 0x05: // else
			if !blk.unreachable {
				for i := len(blk.results) - 1; i >= 0; i-- {
					blk.body.List = append(blk.body.List, &ast.AssignStmt{
						Lhs: []ast.Expr{blk.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.unreachable = false

		case 0x0b: // end
			if !blk.unreachable {
				for i := len(blk.results) - 1; i >= 0; i-- {
					blk.body.List = append(blk.body.List, &ast.AssignStmt{
						Lhs: []ast.Expr{blk.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}

			fn.blocks = fn.blocks[:len(fn.blocks)-1]
			if len(fn.blocks) == 0 {
				if !blk.unreachable && len(fn.typ.results) > 0 {
					res := make([]ast.Expr, len(fn.typ.results))
					for i := range res {
						res[len(res)-1-i] = fn.pop()
					}
					fn.decl.Body.List = append(fn.decl.Body.List, &ast.ReturnStmt{
						Results: res,
					})
				}
				return nil
			}

			if blk.label != "" {
				parent := &fn.blocks[len(fn.blocks)-1]
				if blk.loopPos != 0 {
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Label: ast.NewIdent(blk.label),
						Stmt:  parent.body.List[^blk.loopPos],
					}
				} else {
					parent.body.List = append(parent.body.List, &ast.LabeledStmt{
						Label: ast.NewIdent(blk.label),
						Stmt:  &ast.EmptyStmt{},
					})
				}
			}
			for _, v := range blk.results {
				fn.push(v)
			}

		case 0x0c: // br
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			b := &fn.blocks[len(fn.blocks)-1-int(i)]
			if b.label == "" {
				b.label = fmt.Sprintf("l%d", fn.labels)
				fn.labels++
			}

			if b.loopPos == 0 {
				for i := len(b.results) - 1; i >= 0; i-- {
					blk.body.List = append(blk.body.List, &ast.AssignStmt{
						Lhs: []ast.Expr{b.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}

			blk.unreachable = true
			if int(i) < len(fn.blocks)-1 {
				blk.body.List = append(blk.body.List,
					&ast.BranchStmt{Tok: token.GOTO, Label: ast.NewIdent(b.label)})
			} else {
				ret := &ast.ReturnStmt{}
				if len(fn.typ.results) > 0 {
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for i := len(ret.Results) - 1; i >= 0; i-- {
						ret.Results[i] = fn.pop()
					}
				}
				blk.body.List = append(blk.body.List, ret)
			}

		case 0x0d: // br_if
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			cond := fn.pop()

			b := &fn.blocks[len(fn.blocks)-1-int(i)]
			if b.label == "" {
				b.label = fmt.Sprintf("l%d", fn.labels)
				fn.labels++
			}

			ifStmt := &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X:  cond,
					Op: token.NEQ,
					Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
				},
				Body: &ast.BlockStmt{},
			}

			if b.loopPos == 0 {
				for j := range b.results {
					ifStmt.Body.List = append(ifStmt.Body.List, &ast.AssignStmt{
						Lhs: []ast.Expr{b.results[j]},
						Rhs: []ast.Expr{*fn.stack[len(fn.stack)-len(b.results)+j]},
						Tok: token.ASSIGN,
					})
				}
			}

			if int(i) < len(fn.blocks)-1 {
				ifStmt.Body.List = append(ifStmt.Body.List,
					&ast.BranchStmt{Tok: token.GOTO, Label: ast.NewIdent(b.label)})
			} else {
				ret := &ast.ReturnStmt{}
				if len(fn.typ.results) > 0 {
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for j := range ret.Results {
						ret.Results[j] = *fn.stack[len(fn.stack)-len(ret.Results)+j]
					}
				}
				ifStmt.Body.List = append(ifStmt.Body.List, ret)
			}
			blk.body.List = append(blk.body.List, ifStmt)

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if len(fn.typ.results) > 0 {
				ret.Results = make([]ast.Expr, len(fn.typ.results))
				for i := len(ret.Results) - 1; i >= 0; i-- {
					ret.Results[i] = fn.pop()
				}
			}
			blk.body.List = append(blk.body.List, ret)
			blk.unreachable = true

		case 0x1b: // select
			cond := fn.pop()
			id := fn.makeTempVar()
			blk.body.List = append(blk.body.List, &ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{id},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X:  cond,
					Op: token.NEQ,
					Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Tok: token.ASSIGN,
							Lhs: []ast.Expr{id},
							Rhs: []ast.Expr{fn.pop()},
						},
					},
				},
			})
			fn.push(id)

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushTemp(ast.NewIdent(local(i)))

		case 0x21, 0x22: // local.set, local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			val := fn.pop()
			blk.body.List = append(blk.body.List, &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent(local(i))},
				Rhs: []ast.Expr{val},
				Tok: token.ASSIGN,
			})
			if opcode == 0x22 { // local.tee
				fn.push(val)
			}

		case 0x41: // i32.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(&ast.CallExpr{
				Fun: int32Ident,
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x46: // i32.eq
			fn.i32Cmp(token.EQL)

		case 0x49: // i32.lt_u
			fn.u32Cmp(token.LSS)

		case 0x4a: // i32.gt_s
			fn.i32Cmp(token.GTR)

		case 0x4f: // i32.ge_u
			fn.u32Cmp(token.GEQ)

		case 0x6a: // i32.add
			fn.i32BinOp(token.ADD)

		case 0x6b: // i32.sub
			fn.i32BinOp(token.SUB)

		case 0x70: // i32.rem_u
			fn.u32BinOp(token.REM)

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (fn *funcRef) i32BinOp(op token.Token) {
	fn.pushTemp(&ast.BinaryExpr{
		Y:  fn.pop(),
		X:  fn.pop(),
		Op: op,
	})
}

func (fn *funcRef) u32BinOp(op token.Token) {
	fn.pushTemp(&ast.CallExpr{
		Fun: int32Ident,
		Args: []ast.Expr{&ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op,
		}}})
}

func (fn *funcRef) i32Cmp(op token.Token) {
	id := fn.makeTempVar()
	blk := fn.blocks[len(fn.blocks)-1]
	blk.body.List = append(blk.body.List, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok: token.VAR,
			Specs: []ast.Spec{
				&ast.ValueSpec{
					Names: []*ast.Ident{id},
					Type:  int32Ident,
				},
			},
		},
	}, &ast.IfStmt{
		Cond: &ast.BinaryExpr{Y: fn.pop(), X: fn.pop(), Op: op},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Tok: token.ASSIGN,
					Lhs: []ast.Expr{id},
					Rhs: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: "1"}},
				},
			},
		},
	})
	fn.push(id)
}

func (fn *funcRef) u32Cmp(op token.Token) {
	id := fn.makeTempVar()
	blk := fn.blocks[len(fn.blocks)-1]
	blk.body.List = append(blk.body.List, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok: token.VAR,
			Specs: []ast.Spec{
				&ast.ValueSpec{
					Names: []*ast.Ident{id},
					Type:  int32Ident,
				},
			},
		},
	}, &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Tok: token.ASSIGN,
					Lhs: []ast.Expr{id},
					Rhs: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: "1"}},
				},
			},
		},
	})
	fn.push(id)
}

func (fn *funcRef) makeTempVar() *ast.Ident {
	id := ast.NewIdent("t" + strconv.Itoa(fn.temps))
	fn.temps++
	return id
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("memory")},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}
