package main

import (
	"bufio"
	"bytes"
	_ "embed"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"slices"
	"strconv"
	"strings"
)

//go:embed helpers/helpers.go
var helpersSrc string

type translator struct {
	in  *bufio.Reader
	out ast.File

	packages set[string]
	helpers  set[string]

	types     []funcType
	imports   []importDef
	functions []funcCompiler
	memory    *memoryDef
	globals   []globalDef
	exports   map[string]export
	start     uint64
	data      []dataSegment
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = newID(name)

	t.packages = set[string]{}
	t.helpers = set[string]{}

	// Load Wasm.
	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	if len(t.imports) > 0 {
		t.out.Decls = append(t.createHostInterfaces(), t.out.Decls...)
	}

	t.out.Decls = append([]ast.Decl{
		t.createModuleStruct(),
		t.createNewFunc()},
		t.out.Decls...)

	// Late binding of names.
	for i, fn := range t.functions {
		if fn.decl != nil && fn.decl.Name.Name == "" {
			fn.decl.Name.Name = "f" + strconv.Itoa(i)
		}
	}
	if t.memory != nil && t.memory.id.Name == "" {
		t.memory.id.Name = "memory"
	}
	for i := range t.globals {
		if t.globals[i].id.Name == "" {
			t.globals[i].id.Name = "g" + strconv.Itoa(i)
		}
	}

	// Set imports.
	for pkg := range t.packages {
		t.out.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"` + pkg + `"`},
			}},
		}}, t.out.Decls...)
	}

	// Add helpers.
	fset := token.NewFileSet()
	if len(t.helpers) > 0 {
		f, err := parser.ParseFile(fset, "helpers.go", helpersSrc, 0)
		if err != nil {
			return err
		}
		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && t.helpers.has(fn.Name.Name) {
				t.out.Decls = append(t.out.Decls, decl)
			}
		}
	}

	// Print Go.
	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	err = format.Node(out, fset, &t.out)
	if err != nil {
		return err
	}
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	size, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionImport:
		return t.readImportSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionMemory:
		return t.readMemorySection()
	case sectionGlobal:
		return t.readGlobalSection()
	case sectionExport:
		return t.readExportSection()
	case sectionStart:
		return t.readStartSection()
	case sectionCode:
		return t.readCodeSection()
	case sectionData:
		return t.readDataSection()
	case sectionDataCount:
		return t.readDataCountSection()
	case sectionCustom:
		return t.readCustomSection(int(size))
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		t.types[i].params = buf.String()
		buf.Reset()

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		t.types[i].results = buf.String()
		buf.Reset()
	}
	return nil
}

func (t *translator) readImportSection() error {
	count, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	for range count {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		mod := buf.String()
		buf.Reset()

		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}
		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		name := buf.String()
		buf.Reset()

		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		switch importKind(kind) {
		case functionImport:
			index, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			typ := t.types[index]
			t.imports = append(t.imports, importDef{
				module: mod,
				name:   name,
				typ:    typ,
			})

			args := make([]ast.Expr, len(typ.params)+1)
			args[0] = &ast.UnaryExpr{Op: token.AND, X: newID("m")}
			for i := range typ.params {
				args[i+1] = localVar(i)
			}

			call := &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   &ast.SelectorExpr{X: newID("m"), Sel: newID(internal(mod))},
					Sel: newID(imported(name)),
				},
				Args: args,
			}

			var stmt ast.Stmt
			if len(typ.results) == 0 {
				stmt = &ast.ExprStmt{X: call}
			} else {
				stmt = &ast.ReturnStmt{Results: []ast.Expr{call}}
			}

			fn := funcCompiler{
				typ: typ,
				decl: &ast.FuncDecl{
					Name: &ast.Ident{},
					Recv: modRecvList,
					Type: typ.toAST(),
					Body: &ast.BlockStmt{
						List: []ast.Stmt{stmt},
					},
				},
			}
			t.functions = append(t.functions, fn)
			t.out.Decls = append(t.out.Decls, fn.decl)

		default:
			return fmt.Errorf("unsupported import kind: %x", kind)
		}
	}
	return nil
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	start := len(t.functions)
	t.functions = append(t.functions, make([]funcCompiler, numFuncs)...)
	for i := range numFuncs {
		i += uint64(start)
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.decl = &ast.FuncDecl{
			Name: &ast.Ident{},
			Recv: modRecvList,
			Type: fn.typ.toAST(),
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func (t *translator) readMemorySection() error {
	numMems, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	if numMems == 0 {
		return nil
	}
	if numMems > 1 {
		return fmt.Errorf("multiple memories not supported")
	}

	min, max, err := t.readLimits(65536) // 4GB
	t.memory = &memoryDef{
		min: int(min),
		max: int(max),
	}
	return err
}

func (t *translator) readLimits(def uint64) (min, max uint64, err error) {
	flags, err := readLEB128(t.in)
	if err != nil {
		return
	}
	min, err = readLEB128(t.in)
	if err != nil {
		return
	}
	max = def
	if flags&1 == 1 {
		max, err = readLEB128(t.in)
	}
	return
}

func (t *translator) readGlobalSection() error {
	numGlobals, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.globals = make([]globalDef, numGlobals)
	for i := range t.globals {
		g := &t.globals[i]
		g.id = &ast.Ident{}

		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		g.typ = wasmType(typ)

		mut, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		g.mut = mut == 1

		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		switch opcode {
		case 0x41: // i32.const
			v, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			t.helpers.add("i32_const")
			g.init = &ast.CallExpr{
				Fun:  newID("i32_const"),
				Args: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(v, 10)}},
			}
		case 0x42: // i64.const
			v, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			t.helpers.add("i64_const")
			g.init = &ast.CallExpr{
				Fun:  newID("i64_const"),
				Args: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(v, 10)}},
			}
		case 0x43: // f32.const
			var v uint32
			if err := binary.Read(t.in, binary.LittleEndian, &v); err != nil {
				return err
			}
			t.packages.add("math")
			g.init = &ast.CallExpr{
				Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32frombits")},
				Args: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.FormatUint(uint64(v), 10)}},
			}
		case 0x44: // f64.const
			var v uint64
			if err := binary.Read(t.in, binary.LittleEndian, &v); err != nil {
				return err
			}
			t.packages.add("math")
			g.init = &ast.CallExpr{
				Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64frombits")},
				Args: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.FormatUint(v, 10)}},
			}
		default:
			return fmt.Errorf("unsupported global init opcode: %x", opcode)
		}

		if end, err := t.in.ReadByte(); err != nil {
			return err
		} else if end != 0x0b { // end
			return fmt.Errorf("expected end of init expr, got %x", end)
		}
	}
	return nil
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf strings.Builder
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		_, err = io.CopyN(&buf, t.in, int64(n))
		if err != nil {
			return err
		}
		name := buf.String()
		buf.Reset()

		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			decl := t.functions[index].decl
			decl.Name = ast.NewIdent(exported(name))
		case memoryExport:
			id := "Memory"
			if !strings.EqualFold(name, id) {
				id = exported(name)
			}
			t.memory.id = ast.NewIdent(id)
		case globalExport:
			t.globals[index].id = ast.NewIdent(exported(name))
		}
	}
	return nil
}

func (t *translator) readStartSection() error {
	index, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	// Bitwise not makes the zero value useful (no start function).
	t.start = ^index
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		i += uint64(len(t.imports))
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(&t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn *funcCompiler) error {
	body := &ast.BlockStmt{}
	fn.translator = t
	fn.decl.Body = body
	fn.blocks = []funcBlock{{body: body}}

	numVars, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	// Declare local variables.
	// Parameters are predeclared locals.
	numLocals := len(fn.typ.params)
	for range numVars {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		ids := make([]*ast.Ident, n)
		rhs := make([]ast.Expr, n)
		for i := range int(n) {
			ids[i] = localVar(numLocals)
			rhs[i] = ids[i]
			numLocals++
		}
		body.List = append(body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: ids,
						Type:  wasmType(typ).Ident(),
					},
				},
			},
		}, &ast.AssignStmt{
			Lhs: slices.Repeat([]ast.Expr{newID("_")}, int(n)),
			Tok: token.ASSIGN,
			Rhs: rhs,
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := fn.blocks.top()

		switch opcode {
		case 0x00: // unreachable
			if !blk.unreachable {
				blk.unreachable = true
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun:  newID("panic"),
						Args: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: `"unreachable"`}},
					},
				})
			}

		case 0x01: // nop

		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			var cond ast.Expr
			if opcode == 0x04 { // if
				cond = fn.popCond()
			}

			// Declare block results outside the block.
			results := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				results[i] = fn.newTempVar()
				fn.emit(&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{results[i]},
								Type:  wasmType(t).Ident(),
							},
						},
					},
				})
			}

			childBlk := funcBlock{
				typ:      bt,
				results:  results,
				stackPos: len(fn.stack),
				body:     &ast.BlockStmt{},
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = childBlk.body

			case 0x03: // loop
				// Remember the loop start position.
				// Bitwise not makes the zero value useful (not a loop).
				childBlk.loopPos = ^len(blk.body.List)
				stmt = childBlk.body

			case 0x04: // if
				// We need to remember the if statement
				// so we can attach an else branch.
				childBlk.ifStmt = &ast.IfStmt{Cond: cond, Body: childBlk.body}
				stmt = childBlk.ifStmt
			}

			fn.emit(stmt)
			fn.blocks.append(childBlk)

		case 0x05: // else
			// Set the results of the if branch.
			fn.emit(blk.setResults(fn)...)
			fn.stack = fn.stack[:blk.stackPos]
			// Create a new block at the same level,
			// make it the else branch.
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.unreachable = false

		case 0x0b: // end
			if len(fn.blocks) == 1 { // End of the function body.
				if n := len(fn.typ.results); n > 0 && !blk.unreachable {
					ret := &ast.ReturnStmt{}
					ret.Results = make([]ast.Expr, n)
					copy(ret.Results, fn.stack.last(n))
					fn.emit(ret)
				}
				return nil
			}

			// Set block results, but push them again
			// so they're available to the parent block.
			fn.emit(blk.setResults(fn)...)
			fn.stack = fn.stack[:blk.stackPos]
			for _, val := range blk.results {
				fn.pushConst(val)
			}

			fn.blocks.pop()
			if blk.label != nil { // Add the label if requested.
				if blk.loopPos != 0 { // At the start for loops.
					parent := fn.blocks.top()
					parent.unreachable = blk.unreachable
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Stmt:  parent.body.List[^blk.loopPos],
						Label: blk.label,
					}
				} else { // At the end for other block types.
					fn.emit(&ast.LabeledStmt{
						Stmt:  &ast.EmptyStmt{},
						Label: blk.label,
					})
				}
			}

		case 0x0c: // br
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			fn.emit(fn.branch(n))
			blk.unreachable = true // After an uncoditional goto.

		case 0x0d: // br_if
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			// Conditional break.
			fn.emit(&ast.IfStmt{
				Cond: fn.popCond(),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{fn.branch(n)},
				},
			})

		case 0x0e: // br_table
			numTargets, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			targets := make([]uint64, numTargets)
			for i := range targets {
				target, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				targets[i] = target
			}
			defaultTarget, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			sw := &ast.SwitchStmt{Tag: fn.pop(), Body: &ast.BlockStmt{
				List: []ast.Stmt{&ast.CaseClause{
					Body: []ast.Stmt{fn.branch(defaultTarget)},
				}},
			}}
			for i, target := range targets {
				sw.Body.List = append(sw.Body.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(i)}},
					Body: []ast.Stmt{fn.branch(target)},
				})
			}
			fn.emit(sw)
			blk.unreachable = true // After switch.

		case 0x10: // call
			index, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			target := &t.functions[index]

			args := make([]ast.Expr, len(target.typ.params))
			for i := len(args) - 1; i >= 0; i-- {
				args[i] = fn.pop()
			}

			call := &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("m"),
					Sel: target.decl.Name,
				},
				Args: args,
			}

			if len(target.typ.results) == 0 {
				fn.emit(&ast.ExprStmt{X: call})
				break
			}

			lhs := make([]ast.Expr, len(target.typ.results))
			for i := range lhs {
				lhs[i] = fn.newTempVar()
			}
			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: lhs,
				Rhs: []ast.Expr{call},
			})
			for _, tmp := range lhs {
				fn.pushConst(tmp)
			}

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if n := len(fn.typ.results); n > 0 {
				ret.Results = make([]ast.Expr, n)
				copy(ret.Results, fn.stack.last(n))
			}
			fn.emit(ret)
			blk.unreachable = true // After an uncoditional return.

		case 0x1a: // drop
			fn.emit(&ast.AssignStmt{
				Tok: token.ASSIGN,
				Lhs: []ast.Expr{newID("_")},
				Rhs: []ast.Expr{fn.pop()},
			})

		case 0x1b: // select
			cond := fn.popCond()
			val := fn.newTempVar()
			fn.emit(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{val},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Tok: token.ASSIGN,
							Lhs: []ast.Expr{val},
							Rhs: []ast.Expr{fn.popCopy()}, // must eval
						},
					},
				},
			})
			fn.pushConst(val)

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(localVar(i))

		case 0x21: // local.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{fn.pop()},
				Tok: token.ASSIGN,
			})

		case 0x22: // local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			val := fn.popCopy() // will reuse
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{val},
				Tok: token.ASSIGN,
			})
			fn.pushConst(val)

		case 0x23: // global.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(&ast.SelectorExpr{
				X:   newID("m"),
				Sel: t.globals[i].id,
			})

		case 0x24: // global.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{&ast.SelectorExpr{
					X:   newID("m"),
					Sel: t.globals[i].id,
				}},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{fn.pop()},
			})

		case 0x2c, 0x2d, 0x30, 0x31: // load8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			idx := fn.memory8(offset)
			switch opcode {
			case 0x2c: // i32.load8_s
				fn.push(convert(idx, "int8", "int32"))
			case 0x2d: // i32.load8_u
				fn.push(convert(idx, "int32"))
			case 0x30: // i64.load8_s
				fn.push(convert(idx, "int8", "int64"))
			case 0x31: // i64.load8_u
				fn.push(convert(idx, "int64"))
			}

		case 0x28, 0x29, 0x2a, 0x2b, 0x2e, 0x2f, 0x32, 0x33, 0x34, 0x35: // load
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x28: // i32.load
				fn.push(convert(load("32", idx), "int32"))
			case 0x29: // i64.load
				fn.push(convert(load("64", idx), "int64"))
			case 0x2a: // f32.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32frombits")},
					Args: []ast.Expr{load("32", idx)},
				})
			case 0x2b: // f64.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64frombits")},
					Args: []ast.Expr{load("64", idx)},
				})
			case 0x2e: // i32.load16_s
				fn.push(convert(load("16", idx), "int16", "int32"))
			case 0x2f: // i32.load16_u
				fn.push(convert(load("16", idx), "int32"))
			case 0x32: // i64.load16_s
				fn.push(convert(load("16", idx), "int16", "int64"))
			case 0x33: // i64.load16_u
				fn.push(convert(load("16", idx), "int64"))
			case 0x34: // i64.load32_s
				fn.push(convert(load("32", idx), "int32", "int64"))
			case 0x35: // i64.load32_u
				fn.push(convert(load("32", idx), "int64"))
			}

		case 0x3a, 0x3c: // store8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			val := fn.pop()
			idx := fn.memory8(offset)
			fn.emit(&ast.AssignStmt{
				Lhs: []ast.Expr{idx},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{convert(val, "byte")},
			})

		case 0x36, 0x37, 0x38, 0x39, 0x3b, 0x3d, 0x3e: // store
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			val := fn.pop()
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x36: // i32.store
				fn.emit(store("32", idx, convert(val, "uint32")))
			case 0x37: // i64.store
				fn.emit(store("64", idx, convert(val, "uint64")))
			case 0x38: // f32.store
				fn.packages.add("math")
				fn.emit(store("32", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32bits")},
					Args: []ast.Expr{val},
				}))
			case 0x39: // f64.store
				fn.packages.add("math")
				fn.emit(store("64", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64bits")},
					Args: []ast.Expr{val},
				}))
			case 0x3b: // i32.store16
				fn.emit(store("16", idx, convert(val, "uint16")))
			case 0x3d: // i64.store16
				fn.emit(store("16", idx, convert(val, "uint16")))
			case 0x3e: // i64.store32
				fn.emit(store("32", idx, convert(val, "uint32")))
			}

		case 0x3f: // memory.size
			_, _ = t.in.ReadByte() // reserved
			fn.push(convert(
				&ast.BinaryExpr{
					X: &ast.CallExpr{
						Fun: newID("len"),
						Args: []ast.Expr{&ast.SelectorExpr{
							X:   newID("m"),
							Sel: fn.memory.id,
						}},
					},
					Op: token.SHR,
					Y:  &ast.BasicLit{Kind: token.INT, Value: "16"},
				}, "int32"))

		case 0x40: // memory.grow
			_, err := t.in.ReadByte() // reserved
			if err != nil {
				return err
			}
			fn.helpers.add("memory_grow")
			fn.push(&ast.CallExpr{
				Fun: newID("memory_grow"),
				Args: []ast.Expr{
					&ast.UnaryExpr{
						Op: token.AND,
						X:  &ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
					},
					fn.pop(),
				},
			})

		case 0x41: // i32.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.helpers.add("i32_const")
			fn.pushConst(&ast.CallExpr{
				Fun: newID("i32_const"),
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x42: // i64.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.helpers.add("i64_const")
			fn.pushConst(&ast.CallExpr{
				Fun: newID("i64_const"),
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x43: // f32.const
			var i uint32
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.packages.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("math"),
					Sel: newID("Float32frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(uint64(i), 10),
					Kind:  token.INT,
				}},
			})

		case 0x44: // f64.const
			var i uint64
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.packages.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("math"),
					Sel: newID("Float64frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x45: // i32.eqz
			fn.eqzOp()
		case 0x46: // i32.eq
			fn.cmpOp(token.EQL)
		case 0x47: // i32.ne
			fn.cmpOp(token.NEQ)
		case 0x48: // i32.lt_s
			fn.cmpOp(token.LSS)
		case 0x49: // i32.lt_u
			fn.cmpOpU32(token.LSS)
		case 0x4a: // i32.gt_s
			fn.cmpOp(token.GTR)
		case 0x4b: // i32.gt_u
			fn.cmpOpU32(token.GTR)
		case 0x4c: // i32.le_s
			fn.cmpOp(token.LEQ)
		case 0x4d: // i32.le_u
			fn.cmpOpU32(token.LEQ)
		case 0x4e: // i32.ge_s
			fn.cmpOp(token.GEQ)
		case 0x4f: // i32.ge_u
			fn.cmpOpU32(token.GEQ)

		case 0x50: // i64.eqz
			fn.eqzOp()
		case 0x51: // i64.eq
			fn.cmpOp(token.EQL)
		case 0x52: // i64.ne
			fn.cmpOp(token.NEQ)
		case 0x53: // i64.lt_s
			fn.cmpOp(token.LSS)
		case 0x54: // i64.lt_u
			fn.cmpOpU64(token.LSS)
		case 0x55: // i64.gt_s
			fn.cmpOp(token.GTR)
		case 0x56: // i64.gt_u
			fn.cmpOpU64(token.GTR)
		case 0x57: // i64.le_s
			fn.cmpOp(token.LEQ)
		case 0x58: // i64.le_u
			fn.cmpOpU64(token.LEQ)
		case 0x59: // i64.ge_s
			fn.cmpOp(token.GEQ)
		case 0x5a: // i64.ge_u
			fn.cmpOpU64(token.GEQ)

		case 0x5b: // f32.eq
			fn.cmpOp(token.EQL)
		case 0x5c: // f32.ne
			fn.cmpOp(token.NEQ)
		case 0x5d: // f32.lt
			fn.cmpOp(token.LSS)
		case 0x5e: // f32.gt
			fn.cmpOp(token.GTR)
		case 0x5f: // f32.le
			fn.cmpOp(token.LEQ)
		case 0x60: // f32.ge
			fn.cmpOp(token.GEQ)

		case 0x61: // f64.eq
			fn.cmpOp(token.EQL)
		case 0x62: // f64.ne
			fn.cmpOp(token.NEQ)
		case 0x63: // f64.lt
			fn.cmpOp(token.LSS)
		case 0x64: // f64.gt
			fn.cmpOp(token.GTR)
		case 0x65: // f64.le
			fn.cmpOp(token.LEQ)
		case 0x66: // f64.ge
			fn.cmpOp(token.GEQ)

		case 0x67: // i32.clz
			fn.bitOp("LeadingZeros32")
		case 0x68: // i32.ctz
			fn.bitOp("TrailingZeros32")
		case 0x69: // i32.popcnt
			fn.bitOp("OnesCount32")
		case 0x6a: // i32.add
			fn.binOp(token.ADD)
		case 0x6b: // i32.sub
			fn.binOp(token.SUB)
		case 0x6c: // i32.mul
			fn.binOp(token.MUL)
		case 0x6d: // i32.div_s
			fn.binHelper("i32_div_s", "math")
		case 0x6e: // i32.div_u
			fn.binOpU32(token.QUO)
		case 0x6f: // i32.rem_s
			fn.binOp(token.REM)
		case 0x70: // i32.rem_u
			fn.binOpU32(token.REM)
		case 0x71: // i32.and
			fn.binOp(token.AND)
		case 0x72: // i32.or
			fn.binOp(token.OR)
		case 0x73: // i32.xor
			fn.binOp(token.XOR)
		case 0x74: // i32.shl
			fn.binHelper("i32_shl")
		case 0x75: // i32.shr_s
			fn.binHelper("i32_shr_s")
		case 0x76: // i32.shr_u
			fn.binHelper("i32_shr_u")
		case 0x77: // i32.rotl
			fn.binHelper("i32_rotl", "bits")
		case 0x78: // i32.rotr
			fn.binHelper("i32_rotr", "bits")

		case 0x79: // i64.clz
			fn.bitOp("LeadingZeros64")
		case 0x7a: // i64.ctz
			fn.bitOp("TrailingZeros64")
		case 0x7b: // i64.popcnt
			fn.bitOp("OnesCount64")
		case 0x7c: // i64.add
			fn.binOp(token.ADD)
		case 0x7d: // i64.sub
			fn.binOp(token.SUB)
		case 0x7e: // i64.mul
			fn.binOp(token.MUL)
		case 0x7f: // i64.div_s
			fn.binHelper("i64_div_s", "math")
		case 0x80: // i64.div_u
			fn.binOpU64(token.QUO)
		case 0x81: // i64.rem_s
			fn.binOp(token.REM)
		case 0x82: // i64.rem_u
			fn.binOpU64(token.REM)
		case 0x83: // i64.and
			fn.binOp(token.AND)
		case 0x84: // i64.or
			fn.binOp(token.OR)
		case 0x85: // i64.xor
			fn.binOp(token.XOR)
		case 0x86: // i64.shl
			fn.binHelper("i64_shl")
		case 0x87: // i64.shr_s
			fn.binHelper("i64_shr_s")
		case 0x88: // i64.shr_u
			fn.binHelper("i64_shr_u")
		case 0x89: // i64.rotl
			fn.binHelper("i64_rotl", "bits")
		case 0x8a: // i64.rotr
			fn.binHelper("i64_rotr", "bits")

		case 0x8b: // f32.abs
			fn.uniMath32("Abs")
		case 0x8c: // f32.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x8d: // f32.ceil
			fn.uniMath32("Ceil")
		case 0x8e: // f32.floor
			fn.uniMath32("Floor")
		case 0x8f: // f32.trunc
			fn.uniMath32("Trunc")
		case 0x90: // f32.nearest
			fn.uniMath32("RoundToEven")
		case 0x91: // f32.sqrt
			fn.uniMath32("Sqrt")
		case 0x92: // f32.add
			fn.binOpF32(token.ADD)
		case 0x93: // f32.sub
			fn.binOpF32(token.SUB)
		case 0x94: // f32.mul
			fn.binOpF32(token.MUL)
		case 0x95: // f32.div
			fn.binOpF32(token.QUO) // go.dev/issue/43577
		case 0x96: // f32.min
			fn.binBuiltin("min")
		case 0x97: // f32.max
			fn.binBuiltin("max")
		case 0x98: // f32.copysign
			fn.binMath32("Copysign")

		case 0x99: // f64.abs
			fn.uniMath64("Abs")
		case 0x9a: // f64.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x9b: // f64.ceil
			fn.uniMath64("Ceil")
		case 0x9c: // f64.floor
			fn.uniMath64("Floor")
		case 0x9d: // f64.trunc
			fn.uniMath64("Trunc")
		case 0x9e: // f64.nearest
			fn.uniMath64("RoundToEven")
		case 0x9f: // f64.sqrt
			fn.uniMath64("Sqrt")
		case 0xa0: // f64.add
			fn.binOpF64(token.ADD)
		case 0xa1: // f64.sub
			fn.binOpF64(token.SUB)
		case 0xa2: // f64.mul
			fn.binOpF64(token.MUL)
		case 0xa3: // f64.div
			fn.binOpF64(token.QUO) // go.dev/issue/43577
		case 0xa4: // f64.min
			fn.binBuiltin("min")
		case 0xa5: // f64.max
			fn.binBuiltin("max")
		case 0xa6: // f64.copysign
			fn.binMath64("Copysign")

		case 0xa7: // i32.wrap_i64
			fn.convert("int32")

		case 0xa8: // i32.trunc_f32_s
			fn.uniHelper("i32_trunc_f32_s")
		case 0xa9: // i32.trunc_f32_u
			fn.uniHelper("i32_trunc_f32_u")
		case 0xaa: // i32.trunc_f64_s
			fn.uniHelper("i32_trunc_f64_s")
		case 0xab: // i32.trunc_f64_u
			fn.uniHelper("i32_trunc_f64_u")

		case 0xac: // i64.extend_i32_s
			fn.convert("int64")
		case 0xad: // i64.extend_i32_u
			fn.convert("uint32", "int64")

		case 0xae: // i64.trunc_f32_s
			fn.uniHelper("i64_trunc_f32_s")
		case 0xaf: // i64.trunc_f32_u
			fn.uniHelper("i64_trunc_f32_u")
		case 0xb0: // i64.trunc_f64_s
			fn.uniHelper("i64_trunc_f64_s")
		case 0xb1: // i64.trunc_f64_u
			fn.uniHelper("i64_trunc_f64_u")

		case 0xb2: // f32.convert_i32_s
			fn.convert("float32")
		case 0xb3: // f32.convert_i32_u
			fn.convert("uint32", "float32")
		case 0xb4: // f32.convert_i64_s
			fn.convert("float32")
		case 0xb5: // f32.convert_i64_u
			fn.convert("uint64", "float32")
		case 0xb6: // f32.demote_f64
			fn.convert("float32")

		case 0xb7: // f64.convert_i32_s
			fn.convert("float64")
		case 0xb8: // f64.convert_i32_u
			fn.convert("uint32", "float64")
		case 0xb9: // f64.convert_i64_s
			fn.convert("float64")
		case 0xba: // f64.convert_i64_u
			fn.convert("uint64", "float64")
		case 0xbb: // f64.promote_f32
			fn.convert("float64")

		case 0xbc: // i32.reinterpret_f32
			fn.float32bits()
		case 0xbd: // i64.reinterpret_f64
			fn.float64bits()
		case 0xbe: // f32.reinterpret_i32
			fn.float32frombits()
		case 0xbf: // f64.reinterpret_i64
			fn.float64frombits()

		case 0xfc:
			code, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			switch code {
			case 0x00: // i32.trunc_sat_f32_s
				fn.uniHelper("i32_trunc_sat_f32_s")
			case 0x01: // i32.trunc_sat_f32_u
				fn.uniHelper("i32_trunc_sat_f32_u")
			case 0x02: // i32.trunc_sat_f64_s
				fn.uniHelper("i32_trunc_sat_f64_s")
			case 0x03: // i32.trunc_sat_f64_u
				fn.uniHelper("i32_trunc_sat_f64_u")
			case 0x04: // i64.trunc_sat_f32_s
				fn.uniHelper("i64_trunc_sat_f32_s")
			case 0x05: // i64.trunc_sat_f32_u
				fn.uniHelper("i64_trunc_sat_f32_u")
			case 0x06: // i64.trunc_sat_f64_s
				fn.uniHelper("i64_trunc_sat_f64_s")
			case 0x07: // i64.trunc_sat_f64_u
				fn.uniHelper("i64_trunc_sat_f64_u")

			case 0x0a: // memory.copy
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				_, err = readLEB128(t.in)
				if err != nil {
					return err
				}
				fn.helpers.add("memory_copy")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("memory_copy"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			case 0x0b: // memory.fill
				_, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				fn.helpers.add("memory_fill")
				fn.emit(&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: newID("memory_fill"),
						Args: []ast.Expr{
							&ast.SelectorExpr{X: newID("m"), Sel: fn.memory.id},
							fn.pop(), fn.pop(), fn.pop(),
						},
					},
				})

			default:
				return fmt.Errorf("unsupported opcode: 0xfc %02x", code)
			}

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func (t *translator) readDataCountSection() error {
	_, err := readLEB128(t.in)
	return err
}

func (t *translator) readDataSection() error {
	count, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for range count {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		if index != 0 {
			return fmt.Errorf("unsupported data segment index: %d", index)
		}

		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		if opcode != 0x41 { // i32.const
			return fmt.Errorf("unsupported offset expression opcode: %x", opcode)
		}

		offset, err := readSignedLEB128(t.in)
		if err != nil {
			return err
		}

		end, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		if end != 0x0b {
			return fmt.Errorf("expected end of expression, got %x", end)
		}

		size, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		data := make([]byte, size)
		if _, err := io.ReadFull(t.in, data); err != nil {
			return err
		}
		t.data = append(t.data, dataSegment{offset: int32(offset), init: data})
	}
	return nil
}

func (t *translator) readCustomSection(size int) error {
	data := make([]byte, size)
	if _, err := io.ReadFull(t.in, data); err != nil {
		return err
	}

	r := bytes.NewReader(data)
	n, err := readLEB128(r)
	if err != nil {
		return err
	}
	name := make([]byte, n)
	if _, err := io.ReadFull(r, name); err != nil {
		return err
	}

	if string(name) == "name" {
		return t.readNameSection(r)
	}
	return nil
}

func (t *translator) readNameSection(r *bytes.Reader) error {
	for r.Len() > 0 {
		kind, err := r.ReadByte()
		if err != nil {
			return err
		}
		size, err := readLEB128(r)
		if err != nil {
			return err
		}

		switch nameSubsection(kind) {
		case nameFunction, nameGlobal:
			count, err := readLEB128(r)
			if err != nil {
				return err
			}
			for range count {
				index, err := readLEB128(r)
				if err != nil {
					return err
				}
				n, err := readLEB128(r)
				if err != nil {
					return err
				}
				name := make([]byte, n)
				if _, err := io.ReadFull(r, name); err != nil {
					return err
				}

				var id *ast.Ident
				switch nameSubsection(kind) {
				case nameFunction:
					if int(index) < len(t.functions) {
						id = t.functions[index].decl.Name
					}
				case nameGlobal:
					if int(index) < len(t.globals) {
						id = t.globals[index].id
					}
				}
				if id != nil && id.Name == "" {
					id.Name = internal(string(name))
				}
			}

		default:
			_, err := r.Seek(int64(size), io.SeekCurrent)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

var modRecvList = &ast.FieldList{List: []*ast.Field{{
	Names: []*ast.Ident{newID("m")},
	Type:  newID("Module"),
}}}

func (t *translator) createModuleStruct() ast.Decl {
	var fields []*ast.Field
	if t.memory != nil {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{t.memory.id},
			Type: &ast.ArrayType{
				Elt: newID("byte"),
			},
		})
	}
	for _, g := range t.globals {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{g.id},
			Type:  g.typ.Ident(),
		})
	}
	seen := set[string]{}
	for _, imp := range t.imports {
		if !seen.has(imp.module) {
			seen.add(imp.module)
			fields = append(fields, &ast.Field{
				Names: []*ast.Ident{newID(internal(imp.module))},
				Type:  newID(imported(imp.module)),
			})
		}
	}
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: newID("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

func (t *translator) createHostInterfaces() []ast.Decl {
	ifaces := map[string][]*ast.Field{}

	for _, imp := range t.imports {
		typ := imp.typ.toAST()
		typ.Params.List = append([]*ast.Field{{
			Names: []*ast.Ident{newID("m")},
			Type:  &ast.StarExpr{X: newID("Module")},
		}}, typ.Params.List...)

		ifaces[imp.module] = append(ifaces[imp.module], &ast.Field{
			Names: []*ast.Ident{newID(imported(imp.name))},
			Type:  typ,
		})
	}

	decls := make([]ast.Decl, 0, len(ifaces))
	for name, methods := range ifaces {
		decls = append(decls, &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{&ast.TypeSpec{
				Name: newID(imported(name)),
				Type: &ast.InterfaceType{Methods: &ast.FieldList{List: methods}},
			}},
		})
	}
	return decls
}

func (t *translator) createNewFunc() ast.Decl {
	var params []*ast.Field
	body := &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{newID("m")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.UnaryExpr{
					Op: token.AND,
					X:  &ast.CompositeLit{Type: newID("Module")},
				}},
			},
		},
	}

	seen := set[string]{}
	for i, imp := range t.imports {
		if !seen.has(imp.module) {
			seen.add(imp.module)
			params = append(params, &ast.Field{
				Names: []*ast.Ident{localVar(i)},
				Type:  newID(imported(imp.module)),
			})
			body.List = append(body.List, &ast.AssignStmt{
				Lhs: []ast.Expr{&ast.SelectorExpr{
					X:   newID("m"),
					Sel: newID(internal(imp.module)),
				}},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{localVar(i)},
			})
		}
	}

	if t.memory != nil {
		body.List = append(body.List, &ast.AssignStmt{
			Lhs: []ast.Expr{&ast.SelectorExpr{
				X:   newID("m"),
				Sel: t.memory.id,
			}},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{&ast.CallExpr{
				Fun: newID("make"),
				Args: []ast.Expr{
					&ast.ArrayType{Elt: newID("byte")},
					&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(t.memory.min * 65536)},
				},
			}},
		})
	}

	for _, g := range t.globals {
		body.List = append(body.List, &ast.AssignStmt{
			Lhs: []ast.Expr{&ast.SelectorExpr{
				X:   newID("m"),
				Sel: g.id,
			}},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{g.init},
		})
	}

	for _, seg := range t.data {
		body.List = append(body.List, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: newID("copy"),
				Args: []ast.Expr{
					&ast.SliceExpr{
						X: &ast.SelectorExpr{
							X:   newID("m"),
							Sel: t.memory.id,
						},
						Low: &ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(int(seg.offset))},
					},
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(string(seg.init))},
				},
			},
		})
	}

	if t.start != 0 {
		body.List = append(body.List, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("m"),
					Sel: t.functions[^t.start].decl.Name,
				},
			},
		})
	}

	body.List = append(body.List, &ast.ReturnStmt{Results: []ast.Expr{newID("m")}})

	return &ast.FuncDecl{
		Name: newID("New"),
		Type: &ast.FuncType{
			Params:  &ast.FieldList{List: params},
			Results: &ast.FieldList{List: []*ast.Field{{Type: &ast.StarExpr{X: newID("Module")}}}},
		},
		Body: body,
	}
}
