package main

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"slices"
	"strconv"
)

var (
	int32Ident   = ast.NewIdent("int32")
	int64Ident   = ast.NewIdent("int64")
	uint32Ident  = ast.NewIdent("uint32")
	uint64Ident  = ast.NewIdent("uint64")
	float64Ident = ast.NewIdent("float64")
	modTypIdent  = ast.NewIdent("Module")
	modVarIdent  = ast.NewIdent("m")
	modRecvList  = &ast.FieldList{List: []*ast.Field{{
		Names: []*ast.Ident{modVarIdent},
		Type:  modTypIdent,
	}}}
)

type translator struct {
	in  *bufio.Reader
	out ast.File

	types     []funcType
	functions []funcRef
	exports   map[string]export
	packages  map[string]struct{}
	extras    map[string]struct{}
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = ast.NewIdent(name)
	t.out.Decls = append(t.out.Decls, createModuleStruct())

	t.packages = make(map[string]struct{})
	t.extras = make(map[string]struct{})

	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	for pkg := range t.packages {
		t.out.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"` + pkg + `"`},
			}},
		}}, t.out.Decls...)
	}

	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, token.NewFileSet(), &t.out)
	for extra := range t.extras {
		out.WriteString(extra)
	}
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	_, err = readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionExport:
		return t.readExportSection()
	case sectionCode:
		return t.readCodeSection()
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

type wasmType byte

const (
	i32 wasmType = 127 - iota
	i64
	f32
	f64
)

func (t wasmType) String() string {
	switch t {
	case i32:
		return "int32"
	case i64:
		return "int64"
	case f32:
		return "float32"
	case f64:
		return "float64"
	}
	panic(fmt.Sprintf("unsupported type: %x", byte(t)))
}

type funcType struct {
	params  string // wasmType of parameters
	results string // wasmType of results
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var types []byte
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].params = string(types)

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].results = string(types)
	}
	return nil
}

type funcRef struct {
	typ  funcType
	decl *ast.FuncDecl
	pkgs map[string]struct{}

	cond   ast.Expr
	stack  []*ast.Expr
	blocks []block
	labels int
	temps  int
}

func (fn *funcRef) push(expr ast.Expr) {
	fn.stack = append(fn.stack, &expr)
	fn.cond = nil
}

func (fn *funcRef) pushTemp(expr ast.Expr) {
	id := fn.makeTempVar()
	blk := &fn.blocks[len(fn.blocks)-1]
	blk.append(&ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{id},
		Rhs: []ast.Expr{expr},
	})
	fn.push(id)
}

func (fn *funcRef) pop() ast.Expr {
	expr := *fn.stack[len(fn.stack)-1]
	fn.stack = fn.stack[:len(fn.stack)-1]
	fn.cond = nil
	return expr
}

func (fn *funcRef) popAsCond() ast.Expr {
	cond := fn.cond
	val := fn.pop()

	if cond == nil {
		return &ast.BinaryExpr{
			X: val, Op: token.NEQ,
			Y: &ast.BasicLit{Kind: token.INT, Value: "0"},
		}
	}

	lst := &fn.blocks[len(fn.blocks)-1].body.List
	*lst = (*lst)[:len(*lst)-2]
	return cond
}

type block struct {
	typ         funcType
	body        *ast.BlockStmt
	ifStmt      *ast.IfStmt
	results     []*ast.Ident
	label       string
	loopPos     int
	unreachable bool
}

func (b *block) append(stmts ...ast.Stmt) {
	lst := &b.body.List
	*lst = append(*lst, stmts...)
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.functions = make([]funcRef, numFuncs)
	for i := range t.functions {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.pkgs = t.packages
		fn.decl = &ast.FuncDecl{
			Type: makeFuncType(fn.typ),
			Recv: modRecvList,
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func makeFuncType(t funcType) *ast.FuncType {
	return &ast.FuncType{
		Params:  makeParamsList(t.params),
		Results: makeResultsList(t.results),
	}
}

func makeParamsList(types string) *ast.FieldList {
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(local(i))},
			Type:  ast.NewIdent(wasmType(t).String()),
		}
	}
	return &ast.FieldList{List: list}
}

func makeResultsList(types string) *ast.FieldList {
	if len(types) == 0 {
		return nil
	}
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{Type: ast.NewIdent(wasmType(t).String())}
	}
	return &ast.FieldList{List: list}
}

type exportKind byte

const (
	functionExport exportKind = iota
	tableExport
	memoryExport
	globalExport
)

type export struct {
	kind  exportKind
	index int
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var names []byte
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		names = slices.Grow(names[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, names)
		if err != nil {
			return err
		}

		name := string(names)
		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			if decl := t.functions[index].decl; decl.Name == nil {
				decl.Name = ast.NewIdent(exported(name))
			}
		}
	}
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn funcRef) error {
	fn.decl.Body = &ast.BlockStmt{}
	fn.blocks = []block{{body: fn.decl.Body}}

	numLocals, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	localIndex := len(fn.typ.params)
	for range numLocals {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		names := make([]*ast.Ident, int(n))
		for j := range int(n) {
			names[j] = ast.NewIdent(local(localIndex))
			localIndex++
		}
		fn.decl.Body.List = append(fn.decl.Body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: names,
						Type:  ast.NewIdent(wasmType(typ).String()),
					},
				},
			},
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := &fn.blocks[len(fn.blocks)-1]

		switch opcode {
		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			var cond ast.Expr
			if opcode == 0x04 { // if
				cond = fn.popAsCond()
			}

			resultVars := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				resultVars[i] = fn.makeTempVar()
				blk.append(&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{resultVars[i]},
								Type:  ast.NewIdent(wasmType(t).String()),
							},
						},
					},
				})
			}

			b := block{
				typ:     bt,
				body:    &ast.BlockStmt{},
				results: resultVars,
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = b.body

			case 0x03: // loop
				b.loopPos = ^len(blk.body.List)
				stmt = b.body

			case 0x04: // if
				b.ifStmt = &ast.IfStmt{Cond: cond, Body: b.body}
				stmt = b.ifStmt
			}

			fn.blocks = append(fn.blocks, b)
			blk.append(stmt)

		case 0x05: // else
			if !blk.unreachable {
				for i := len(blk.results) - 1; i >= 0; i-- {
					blk.append(&ast.AssignStmt{
						Lhs: []ast.Expr{blk.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.unreachable = false

		case 0x0b: // end
			if !blk.unreachable {
				for i := len(blk.results) - 1; i >= 0; i-- {
					blk.append(&ast.AssignStmt{
						Lhs: []ast.Expr{blk.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}

			fn.blocks = fn.blocks[:len(fn.blocks)-1]
			if len(fn.blocks) == 0 {
				if !blk.unreachable && len(fn.typ.results) > 0 {
					res := make([]ast.Expr, len(fn.typ.results))
					for i := range res {
						res[len(res)-1-i] = fn.pop()
					}
					fn.decl.Body.List = append(fn.decl.Body.List, &ast.ReturnStmt{
						Results: res,
					})
				}
				return nil
			}

			if blk.label != "" {
				parent := &fn.blocks[len(fn.blocks)-1]
				if blk.loopPos != 0 {
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Label: ast.NewIdent(blk.label),
						Stmt:  parent.body.List[^blk.loopPos],
					}
				} else {
					parent.append(&ast.LabeledStmt{
						Label: ast.NewIdent(blk.label),
						Stmt:  &ast.EmptyStmt{},
					})
				}
			}
			for _, id := range blk.results {
				fn.push(id)
			}

		case 0x0c: // br
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			b := &fn.blocks[len(fn.blocks)-1-int(i)]
			if b.label == "" {
				b.label = "l" + strconv.Itoa(fn.labels)
				fn.labels++
			}

			if b.loopPos == 0 {
				for i := len(b.results) - 1; i >= 0; i-- {
					blk.append(&ast.AssignStmt{
						Lhs: []ast.Expr{b.results[i]},
						Rhs: []ast.Expr{fn.pop()},
						Tok: token.ASSIGN,
					})
				}
			}

			blk.unreachable = true
			if int(i) < len(fn.blocks)-1 {
				blk.append(&ast.BranchStmt{
					Tok: token.GOTO, Label: ast.NewIdent(b.label)})
			} else {
				ret := &ast.ReturnStmt{}
				if len(fn.typ.results) > 0 {
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for i := len(ret.Results) - 1; i >= 0; i-- {
						ret.Results[i] = fn.pop()
					}
				}
				blk.append(ret)
			}

		case 0x0d: // br_if
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			b := &fn.blocks[len(fn.blocks)-1-int(i)]
			if b.label == "" {
				b.label = "l" + strconv.Itoa(fn.labels)
				fn.labels++
			}

			ifStmt := &ast.IfStmt{
				Cond: fn.popAsCond(),
				Body: &ast.BlockStmt{},
			}

			if b.loopPos == 0 {
				for j := range b.results {
					ifStmt.Body.List = append(ifStmt.Body.List, &ast.AssignStmt{
						Lhs: []ast.Expr{b.results[j]},
						Rhs: []ast.Expr{*fn.stack[len(fn.stack)-len(b.results)+j]},
						Tok: token.ASSIGN,
					})
				}
			}

			if int(i) < len(fn.blocks)-1 {
				ifStmt.Body.List = append(ifStmt.Body.List,
					&ast.BranchStmt{Tok: token.GOTO, Label: ast.NewIdent(b.label)})
			} else {
				ret := &ast.ReturnStmt{}
				if len(fn.typ.results) > 0 {
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for j := range ret.Results {
						ret.Results[j] = *fn.stack[len(fn.stack)-len(ret.Results)+j]
					}
				}
				ifStmt.Body.List = append(ifStmt.Body.List, ret)
			}
			blk.append(ifStmt)

		case 0x0e: // br_table
			numTargets, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			targets := make([]int, numTargets)
			for i := range targets {
				target, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				targets[i] = int(target)
			}
			defaultTarget, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			index := fn.pop()

			arity := len(fn.blocks[len(fn.blocks)-1-int(defaultTarget)].results)
			if int(defaultTarget) == len(fn.blocks)-1 {
				arity = len(fn.typ.results)
			}
			args := make([]ast.Expr, arity)
			for i := range args {
				args[i] = fn.pop()
			}

			sw := &ast.SwitchStmt{Tag: index, Body: &ast.BlockStmt{}}
			for i, target := range targets {
				sw.Body.List = append(sw.Body.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(i)}},
					Body: fn.branchStmts(target, args),
				})
			}
			sw.Body.List = append(sw.Body.List, &ast.CaseClause{
				Body: fn.branchStmts(int(defaultTarget), args),
			})
			blk.append(sw)
			blk.unreachable = true

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if len(fn.typ.results) > 0 {
				ret.Results = make([]ast.Expr, len(fn.typ.results))
				for i := len(ret.Results) - 1; i >= 0; i-- {
					ret.Results[i] = fn.pop()
				}
			}
			blk.append(ret)
			blk.unreachable = true

		case 0x1b: // select
			cond := fn.popAsCond()
			id := fn.makeTempVar()
			blk.append(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{id},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Tok: token.ASSIGN,
							Lhs: []ast.Expr{id},
							Rhs: []ast.Expr{fn.pop()},
						},
					},
				},
			})
			fn.push(id)

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushTemp(ast.NewIdent(local(i)))

		case 0x21, 0x22: // local.set, local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			val := fn.pop()
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent(local(i))},
				Rhs: []ast.Expr{val},
				Tok: token.ASSIGN,
			})
			if opcode == 0x22 { // local.tee
				fn.push(val)
			}

		case 0x41: // i32.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(&ast.CallExpr{
				Fun: int32Ident,
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x42: // i64.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(&ast.CallExpr{
				Fun: int64Ident,
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x44: // f64.const
			var i uint64
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.pkgs["math"] = struct{}{}
			fn.push(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("math"),
					Sel: ast.NewIdent("Float64frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x45: // i32.eqz
			fn.eqzOp()
		case 0x46: // i32.eq
			fn.cmpOp(token.EQL)
		case 0x47: // i32.ne
			fn.cmpOp(token.NEQ)
		case 0x48: // i32.lt_s
			fn.cmpOp(token.LSS)
		case 0x49: // i32.lt_u
			fn.cmpOpU32(token.LSS)
		case 0x4a: // i32.gt_s
			fn.cmpOp(token.GTR)
		case 0x4b: // i32.gt_u
			fn.cmpOpU32(token.GTR)
		case 0x4c: // i32.le_s
			fn.cmpOp(token.LEQ)
		case 0x4d: // i32.le_u
			fn.cmpOpU32(token.LEQ)
		case 0x4e: // i32.ge_s
			fn.cmpOp(token.GEQ)
		case 0x4f: // i32.ge_u
			fn.cmpOpU32(token.GEQ)

		case 0x50: // i64.eqz
			fn.eqzOp()
		case 0x51: // i64.eq
			fn.cmpOp(token.EQL)
		case 0x52: // i64.ne
			fn.cmpOp(token.NEQ)
		case 0x53: // i64.lt_s
			fn.cmpOp(token.LSS)
		case 0x54: // i64.lt_u
			fn.cmpOpU64(token.LSS)
		case 0x55: // i64.gt_s
			fn.cmpOp(token.GTR)
		case 0x56: // i64.gt_u
			fn.cmpOpU64(token.GTR)
		case 0x57: // i64.le_s
			fn.cmpOp(token.LEQ)
		case 0x58: // i64.le_u
			fn.cmpOpU64(token.LEQ)
		case 0x59: // i64.ge_s
			fn.cmpOp(token.GEQ)
		case 0x5a: // i64.ge_u
			fn.cmpOpU64(token.GEQ)

		case 0x61: // f64.eq
			fn.cmpOp(token.EQL)
		case 0x63: // f64.lt
			fn.cmpOp(token.LSS)
		case 0x64: // f64.gt
			fn.cmpOp(token.GTR)
		case 0x65: // f64.le
			fn.cmpOp(token.LEQ)
		case 0x66: // f64.ge
			fn.cmpOp(token.GEQ)

		case 0x67: // i32.clz
			fn.bitOp("LeadingZeros32", int32Ident, uint32Ident)
		case 0x68: // i32.ctz
			fn.bitOp("TrailingZeros32", int32Ident, uint32Ident)
		case 0x69: // i32.popcnt
			fn.bitOp("OnesCount32", int32Ident, uint32Ident)
		case 0x6a: // i32.add
			fn.binOp(token.ADD)
		case 0x6b: // i32.sub
			fn.binOp(token.SUB)
		case 0x6c: // i32.mul
			fn.binOp(token.MUL)
		case 0x6d: // i32.div_s
			fn.binOp(token.QUO)
		case 0x6e: // i32.div_u
			fn.binOpU32(token.QUO)
		case 0x6f: // i32.rem_s
			fn.binOp(token.REM)
		case 0x70: // i32.rem_u
			fn.binOpU32(token.REM)
		case 0x71: // i32.and
			fn.binOp(token.AND)
		case 0x72: // i32.or
			fn.binOp(token.OR)
		case 0x73: // i32.xor
			fn.binOp(token.XOR)
		case 0x74: // i32.shl
			fn.binOp(token.SHL)
		case 0x75: // i32.shr_s
			fn.binOp(token.SHR)
		case 0x76: // i32.shr_u
			fn.binOpU32(token.SHR)
		case 0x77, 0x78: // i32.rotl, i32.rotr
			fn.rotOp("RotateLeft32", opcode == 0x77, int32Ident, uint32Ident)

		case 0x79: // i64.clz
			fn.bitOp("LeadingZeros64", int64Ident, uint64Ident)
		case 0x7a: // i64.ctz
			fn.bitOp("TrailingZeros64", int64Ident, uint64Ident)
		case 0x7b: // i64.popcnt
			fn.bitOp("OnesCount64", int64Ident, uint64Ident)
		case 0x7c: // i64.add
			fn.binOp(token.ADD)
		case 0x7d: // i64.sub
			fn.binOp(token.SUB)
		case 0x7e: // i64.mul
			fn.binOp(token.MUL)
		case 0x7f: // i64.div_s
			fn.binOp(token.QUO)
		case 0x80: // i64.div_u
			fn.binOpU64(token.QUO)
		case 0x81: // i64.rem_s
			fn.binOp(token.REM)
		case 0x82: // i64.rem_u
			fn.binOpU64(token.REM)
		case 0x83: // i64.and
			fn.binOp(token.AND)
		case 0x84: // i64.or
			fn.binOp(token.OR)
		case 0x85: // i64.xor
			fn.binOp(token.XOR)
		case 0x86: // i64.shl
			fn.binOp(token.SHL)
		case 0x87: // i64.shr_s
			fn.binOp(token.SHR)
		case 0x88: // i64.shr_u
			fn.binOpU64(token.SHR)
		case 0x89, 0x8a: // i64.rotl, i64.rotr
			fn.rotOp("RotateLeft64", opcode == 0x89, int64Ident, uint64Ident)

		case 0x99: // f64.abs
			fn.uniMath("Abs")
		case 0x9a: // f64.neg
			fn.pushTemp(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x9b: // f64.ceil
			fn.uniMath("Ceil")
		case 0x9c: // f64.floor
			fn.uniMath("Floor")
		case 0x9d: // f64.trunc
			fn.uniMath("Trunc")
		case 0x9e: // f64.nearest
			fn.uniMath("RoundToEven")
		case 0x9f: // f64.sqrt
			fn.uniMath("Sqrt")
		case 0xa0: // f64.add
			fn.binOp(token.ADD)
		case 0xa1: // f64.sub
			fn.binOp(token.SUB)
		case 0xa2: // f64.mul
			fn.binOp(token.MUL)
		case 0xa3: // f64.div
			fn.binOp(token.QUO)

		case 0xa6: // f64.copysign
			fn.binMath("Copysign")
		case 0xa7: // i32.wrap_i64
			fn.pushTemp(&ast.CallExpr{Fun: int32Ident, Args: []ast.Expr{fn.pop()}})

		case 0xb9: // f64.convert_i64_s
			fn.pushTemp(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{fn.pop()}})

		case 0xbd: // i64.reinterpret_f64
			fn.float64bits()

		case 0xfc:
			code, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			switch code {
			case 0x06: // i64.trunc_sat_f64_s
				fn.pkgs["math"] = struct{}{}
				t.extras[i64_trunc_sat_f64_s] = struct{}{}
				fn.pushTemp(&ast.CallExpr{
					Fun:  ast.NewIdent("i64_trunc_sat_f64_s"),
					Args: []ast.Expr{fn.pop()}})
			default:
				return fmt.Errorf("unsupported opcode: 0xfc %02x", code)
			}

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (fn *funcRef) branchStmts(labelIdx int, args []ast.Expr) []ast.Stmt {
	b := &fn.blocks[len(fn.blocks)-1-labelIdx]
	if b.label == "" {
		b.label = "l" + strconv.Itoa(fn.labels)
		fn.labels++
	}

	var stmts []ast.Stmt
	if b.loopPos == 0 {
		for i := range b.results {
			stmts = append(stmts, &ast.AssignStmt{
				Lhs: []ast.Expr{b.results[len(b.results)-1-i]},
				Rhs: []ast.Expr{args[i]},
				Tok: token.ASSIGN,
			})
		}
	}

	if labelIdx < len(fn.blocks)-1 {
		stmts = append(stmts, &ast.BranchStmt{Tok: token.GOTO, Label: ast.NewIdent(b.label)})
	} else {
		ret := &ast.ReturnStmt{}
		if len(fn.typ.results) > 0 {
			ret.Results = make([]ast.Expr, len(fn.typ.results))
			for i := range ret.Results {
				ret.Results[len(ret.Results)-1-i] = args[i]
			}
		}
		stmts = append(stmts, ret)
	}
	return stmts
}

func (fn *funcRef) binOp(op token.Token) {
	fn.pushTemp(&ast.BinaryExpr{
		Y:  fn.pop(),
		X:  fn.pop(),
		Op: op,
	})
}

func (fn *funcRef) binOpU32(op token.Token) {
	fn.pushTemp(&ast.CallExpr{
		Fun: int32Ident,
		Args: []ast.Expr{&ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op,
		}}})
}

func (fn *funcRef) binOpU64(op token.Token) {
	fn.pushTemp(&ast.CallExpr{
		Fun: int64Ident,
		Args: []ast.Expr{&ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint64Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint64Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op,
		}}})
}

func (fn *funcRef) bitOp(name string, intIndent, uintIndent *ast.Ident) {
	fn.pkgs["math/bits"] = struct{}{}
	fn.pushTemp(&ast.CallExpr{
		Fun: intIndent,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("bits"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{&ast.CallExpr{
				Fun:  uintIndent,
				Args: []ast.Expr{fn.pop()},
			}},
		}},
	})
}

func (fn *funcRef) rotOp(name string, rotl bool, intIndent, uintIndent *ast.Ident) {
	var count ast.Expr = &ast.CallExpr{
		Fun:  ast.NewIdent("int"),
		Args: []ast.Expr{fn.pop()},
	}
	if !rotl {
		count = &ast.UnaryExpr{Op: token.SUB, X: count}
	}

	fn.pkgs["math/bits"] = struct{}{}
	fn.pushTemp(&ast.CallExpr{
		Fun: intIndent,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("bits"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{
				&ast.CallExpr{
					Fun:  uintIndent,
					Args: []ast.Expr{fn.pop()},
				},
				count,
			},
		}},
	})
}

func (fn *funcRef) uniMath(name string) {
	fn.pkgs["math"] = struct{}{}
	fn.pushTemp(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent(name),
		},
		Args: []ast.Expr{fn.pop()},
	})
}

func (fn *funcRef) binMath(name string) {
	fn.pkgs["math"] = struct{}{}
	y := fn.pop()
	x := fn.pop()
	fn.pushTemp(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent(name),
		},
		Args: []ast.Expr{x, y},
	})
}

func (fn *funcRef) float64bits() {
	fn.pkgs["math"] = struct{}{}
	fn.pushTemp(&ast.CallExpr{
		Fun: int64Ident,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("math"),
				Sel: ast.NewIdent("Float64bits"),
			},
			Args: []ast.Expr{fn.pop()},
		}},
	})
}

func (fn *funcRef) eqzOp() {
	fn.emitCondition(&ast.BinaryExpr{
		X:  fn.pop(),
		Op: token.EQL,
		Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
	})
}

func (fn *funcRef) cmpOp(op token.Token) {
	fn.emitCondition(&ast.BinaryExpr{Y: fn.pop(), X: fn.pop(), Op: op})
}

func (fn *funcRef) cmpOpU32(op token.Token) {
	fn.emitCondition(&ast.BinaryExpr{
		Y: &ast.CallExpr{
			Fun:  uint32Ident,
			Args: []ast.Expr{fn.pop()},
		},
		X: &ast.CallExpr{
			Fun:  uint32Ident,
			Args: []ast.Expr{fn.pop()},
		},
		Op: op})
}

func (fn *funcRef) cmpOpU64(op token.Token) {
	fn.emitCondition(&ast.BinaryExpr{
		Y: &ast.CallExpr{
			Fun:  uint64Ident,
			Args: []ast.Expr{fn.pop()},
		},
		X: &ast.CallExpr{
			Fun:  uint64Ident,
			Args: []ast.Expr{fn.pop()},
		},
		Op: op})
}

func (fn *funcRef) emitCondition(cond ast.Expr) {
	id := fn.makeTempVar()

	blk := &fn.blocks[len(fn.blocks)-1]
	blk.append(&ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok: token.VAR,
			Specs: []ast.Spec{
				&ast.ValueSpec{
					Names: []*ast.Ident{id},
					Type:  int32Ident,
				},
			},
		},
	}, &ast.IfStmt{
		Cond: cond,
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Tok: token.ASSIGN,
					Lhs: []ast.Expr{id},
					Rhs: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: "1"}},
				},
			},
		},
	})
	fn.push(id)
	fn.cond = cond
}

func (fn *funcRef) makeTempVar() *ast.Ident {
	id := ast.NewIdent("t" + strconv.Itoa(fn.temps))
	fn.temps++
	return id
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("memory")},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}

const (
	i64_trunc_sat_f64_s = `
func i64_trunc_sat_f64_s(f float64) int64 {
	f = math.Trunc(f)
	switch {
	case f < math.MinInt64:
		return math.MinInt64
	case f >= math.MaxInt64:
		return math.MaxInt64
	case math.IsNaN(f):
		return 0
	}
	return int64(f)
}
`
)
