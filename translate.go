package main

import (
	"bufio"
	_ "embed"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"slices"
	"strconv"
)

//go:embed helpers/helpers.go
var helpersSrc string

type translator struct {
	in  *bufio.Reader
	out ast.File

	types     []funcType
	functions []funcCompiler
	exports   map[string]export
	packages  set[string]
	helpers   set[string]
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = newID(name)
	t.out.Decls = append(t.out.Decls, createModuleStruct())

	t.packages = set[string]{}
	t.helpers = set[string]{}

	// Load Wasm.
	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	// Late binding of function names.
	for i, fn := range t.functions {
		if fn.decl != nil && fn.decl.Name.Name == "" {
			fn.decl.Name.Name = "f" + strconv.Itoa(i)
		}
	}

	// Set imports.
	for pkg := range t.packages {
		t.out.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"` + pkg + `"`},
			}},
		}}, t.out.Decls...)
	}

	// Add helpers.
	fset := token.NewFileSet()
	if len(t.helpers) > 0 {
		f, err := parser.ParseFile(fset, "helpers.go", helpersSrc, 0)
		if err != nil {
			return err
		}
		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && t.helpers.has(fn.Name.Name) {
				t.out.Decls = append(t.out.Decls, decl)
			}
		}
	}

	// Print Go.
	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, fset, &t.out)
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	_, err = readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionExport:
		return t.readExportSection()
	case sectionCode:
		return t.readCodeSection()
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var types []byte
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].params = string(types)

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].results = string(types)
	}
	return nil
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.functions = make([]funcCompiler, numFuncs)
	for i := range t.functions {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.decl = &ast.FuncDecl{
			Recv: modRecvList,
			Type: fn.typ.toAST(),
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var names []byte
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		names = slices.Grow(names[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, names)
		if err != nil {
			return err
		}

		name := string(names)
		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			decl := t.functions[index].decl
			if decl.Name == nil {
				decl.Name = &ast.Ident{}
			}
			decl.Name.Name = exported(name)
		}
	}
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(&t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn *funcCompiler) error {
	body := &ast.BlockStmt{}
	fn.translator = t
	fn.decl.Body = body
	fn.blocks = []funcBlock{{body: body}}

	numVars, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	// Declare local variables.
	// Parameters are predeclared locals.
	numLocals := len(fn.typ.params)
	for range numVars {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		names := make([]*ast.Ident, int(n))
		for i := range int(n) {
			names[i] = localVar(numLocals)
			numLocals++
		}
		body.List = append(body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: names,
						Type:  wasmType(typ).Ident(),
					},
				},
			},
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := &fn.blocks[len(fn.blocks)-1]

		switch opcode {
		case 0x00: // unreachable
			blk.append(&ast.ExprStmt{
				X: &ast.CallExpr{
					Fun:  newID("panic"),
					Args: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: `"unreachable"`}},
				},
			})
			blk.unreachable = true

		case 0x01: // nop

		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			var cond ast.Expr
			if opcode == 0x04 { // if
				cond = fn.popCond()
			}

			// Declare block results outside the block.
			results := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				results[i] = fn.newTempVar()
				blk.append(&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{results[i]},
								Type:  wasmType(t).Ident(),
							},
						},
					},
				})
			}

			childBlk := funcBlock{
				typ:     bt,
				body:    &ast.BlockStmt{},
				results: results,
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = childBlk.body

			case 0x03: // loop
				// Remember the loop start position.
				// Bitwise not makes the zero value useful (not a loop).
				childBlk.loopPos = ^len(blk.body.List)
				stmt = childBlk.body

			case 0x04: // if
				// We need to remember the if statement
				// so we can attach an else branch.
				childBlk.ifStmt = &ast.IfStmt{Cond: cond, Body: childBlk.body}
				stmt = childBlk.ifStmt
			}

			fn.blocks = append(fn.blocks, childBlk)
			blk.append(stmt)

		case 0x05: // else
			// Set the results of the if branch.
			blk.setResults(fn)
			// Create a new block at the same level,
			// make it the else branch.
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.unreachable = false

		case 0x0b: // end
			if len(fn.blocks) == 1 { // End of the function body.
				if !blk.unreachable && len(fn.typ.results) > 0 {
					ret := &ast.ReturnStmt{}
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for i := len(ret.Results) - 1; i >= 0; i-- {
						ret.Results[i] = fn.pop()
					}
					blk.append(ret)
				}
				return nil
			}

			// Set block results, but push them again
			// so they're available to the parent block.
			blk.setResults(fn)
			for _, val := range blk.results {
				fn.pushConst(val)
			}

			pop(&fn.blocks)
			if blk.label != nil { // Add the label if requested.
				parent := &fn.blocks[len(fn.blocks)-1]
				if blk.loopPos != 0 { // At the start for loops.
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Stmt:  parent.body.List[^blk.loopPos],
						Label: blk.label,
					}
				} else { // At the end for other block types.
					parent.append(&ast.LabeledStmt{
						Stmt:  &ast.EmptyStmt{},
						Label: blk.label,
					})
				}
			}

		case 0x0c: // br
			// How many nested blocks are we exiting?
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			n = uint64(len(fn.blocks)) - n - 1

			blk.append(fn.branch(n))
			blk.unreachable = true // After an uncoditional goto.

		case 0x0d: // br_if
			// How many nested blocks would we exit?
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			n = uint64(len(fn.blocks)) - n - 1

			// Conditional break.
			blk.append(&ast.IfStmt{
				Cond: fn.popCond(),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{fn.branch(n)},
				},
			})

		case 0x0e: // br_table
			numTargets, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			targets := make([]uint64, numTargets)
			for i := range targets {
				target, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				targets[i] = uint64(len(fn.blocks)) - target - 1
			}
			defaultTarget, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			defaultTarget = uint64(len(fn.blocks)) - defaultTarget - 1

			sw := &ast.SwitchStmt{Tag: fn.pop(), Body: &ast.BlockStmt{
				List: []ast.Stmt{&ast.CaseClause{
					Body: []ast.Stmt{fn.branch(defaultTarget)},
				}},
			}}
			for i, target := range targets {
				sw.Body.List = append(sw.Body.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(i)}},
					Body: []ast.Stmt{fn.branch(target)},
				})
			}
			blk.append(sw)
			blk.unreachable = true // After switch.

		case 0x10: // call
			index, err := readLEB128(t.in)
			if err != nil {
				return err
			}

			target := &t.functions[index]
			if target.decl.Name == nil {
				target.decl.Name = &ast.Ident{}
			}

			args := make([]ast.Expr, len(target.typ.params))
			for i := len(args) - 1; i >= 0; i-- {
				args[i] = fn.pop()
			}

			call := &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("m"),
					Sel: target.decl.Name,
				},
				Args: args,
			}

			if len(target.typ.results) == 0 {
				blk.append(&ast.ExprStmt{X: call})
				break
			}

			lhs := make([]ast.Expr, len(target.typ.results))
			for i := range lhs {
				lhs[i] = fn.newTempVar()
			}
			blk.append(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: lhs,
				Rhs: []ast.Expr{call},
			})
			for _, tmp := range lhs {
				fn.pushConst(tmp)
			}

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if len(fn.typ.results) > 0 {
				ret.Results = make([]ast.Expr, len(fn.typ.results))
				for i := len(ret.Results) - 1; i >= 0; i-- {
					ret.Results[i] = fn.pop()
				}
			}
			blk.append(ret)
			blk.unreachable = true // After an uncoditional return.

		case 0x1a: // drop
			fn.popCopy() // must eval

		case 0x1b: // select
			cond := fn.popCond()
			val := fn.newTempVar()
			blk.append(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{val},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Tok: token.ASSIGN,
							Lhs: []ast.Expr{val},
							Rhs: []ast.Expr{fn.popCopy()}, // must eval
						},
					},
				},
			})
			fn.pushConst(val)

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(localVar(i))

		case 0x21: // local.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{fn.pop()},
				Tok: token.ASSIGN,
			})

		case 0x22: // local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			val := fn.popCopy() // will reuse
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{localVar(i)},
				Rhs: []ast.Expr{val},
				Tok: token.ASSIGN,
			})
			fn.pushConst(val)

		case 0x2c, 0x2d, 0x30, 0x31: // load8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			idx := fn.memory8(offset)
			switch opcode {
			case 0x2c: // i32.load8_s
				fn.push(convert(idx, "int8", "int32"))
			case 0x2d: // i32.load8_u
				fn.push(convert(idx, "int32"))
			case 0x30: // i64.load8_s
				fn.push(convert(idx, "int8", "int64"))
			case 0x31: // i64.load8_u
				fn.push(convert(idx, "int64"))
			}

		case 0x28, 0x29, 0x2a, 0x2b, 0x2e, 0x2f, 0x32, 0x33, 0x34, 0x35: // load
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x28: // i32.load
				fn.push(convert(load("32", idx), "int32"))
			case 0x29: // i64.load
				fn.push(convert(load("64", idx), "int64"))
			case 0x2a: // f32.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32frombits")},
					Args: []ast.Expr{load("32", idx)},
				})
			case 0x2b: // f64.load
				fn.packages.add("math")
				fn.push(&ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64frombits")},
					Args: []ast.Expr{load("64", idx)},
				})
			case 0x2e: // i32.load16_s
				fn.push(convert(load("16", idx), "int16", "int32"))
			case 0x2f: // i32.load16_u
				fn.push(convert(load("16", idx), "int32"))
			case 0x32: // i64.load16_s
				fn.push(convert(load("16", idx), "int16", "int64"))
			case 0x33: // i64.load16_u
				fn.push(convert(load("16", idx), "int64"))
			case 0x34: // i64.load32_s
				fn.push(convert(load("32", idx), "int32", "int64"))
			case 0x35: // i64.load32_u
				fn.push(convert(load("32", idx), "int64"))
			}

		case 0x3a, 0x3c: // store8
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			val := fn.pop()
			idx := fn.memory8(offset)
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{idx},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{convert(val, "byte")},
			})

		case 0x36, 0x37, 0x38, 0x39, 0x3b, 0x3d, 0x3e: // store
			_, err := readLEB128(t.in) // align
			if err != nil {
				return err
			}
			offset, err := readLEB128(t.in)
			if err != nil { // offset
				return err
			}

			fn.packages.add("encoding/binary")
			val := fn.pop()
			idx := fn.memoryN(offset)

			switch opcode {
			case 0x36: // i32.store
				blk.append(store("32", idx, convert(val, "uint32")))
			case 0x37: // i64.store
				blk.append(store("64", idx, convert(val, "uint64")))
			case 0x38: // f32.store
				fn.packages.add("math")
				blk.append(store("32", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float32bits")},
					Args: []ast.Expr{val},
				}))
			case 0x39: // f64.store
				fn.packages.add("math")
				blk.append(store("64", idx, &ast.CallExpr{
					Fun:  &ast.SelectorExpr{X: newID("math"), Sel: newID("Float64bits")},
					Args: []ast.Expr{val},
				}))
			case 0x3b: // i32.store16
				blk.append(store("16", idx, convert(val, "uint16")))
			case 0x3d: // i64.store16
				blk.append(store("16", idx, convert(val, "uint16")))
			case 0x3e: // i64.store32
				blk.append(store("32", idx, convert(val, "uint32")))
			}

		case 0x41: // i32.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushConst(&ast.CallExpr{
				Fun: newID("int32"),
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x42: // i64.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushConst(&ast.CallExpr{
				Fun: newID("int64"),
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x43: // f32.const
			var i uint32
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.packages.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("math"),
					Sel: newID("Float32frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(uint64(i), 10),
					Kind:  token.INT,
				}},
			})

		case 0x44: // f64.const
			var i uint64
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.packages.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   newID("math"),
					Sel: newID("Float64frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x45: // i32.eqz
			fn.eqzOp()
		case 0x46: // i32.eq
			fn.cmpOp(token.EQL)
		case 0x47: // i32.ne
			fn.cmpOp(token.NEQ)
		case 0x48: // i32.lt_s
			fn.cmpOp(token.LSS)
		case 0x49: // i32.lt_u
			fn.cmpOpU32(token.LSS)
		case 0x4a: // i32.gt_s
			fn.cmpOp(token.GTR)
		case 0x4b: // i32.gt_u
			fn.cmpOpU32(token.GTR)
		case 0x4c: // i32.le_s
			fn.cmpOp(token.LEQ)
		case 0x4d: // i32.le_u
			fn.cmpOpU32(token.LEQ)
		case 0x4e: // i32.ge_s
			fn.cmpOp(token.GEQ)
		case 0x4f: // i32.ge_u
			fn.cmpOpU32(token.GEQ)

		case 0x50: // i64.eqz
			fn.eqzOp()
		case 0x51: // i64.eq
			fn.cmpOp(token.EQL)
		case 0x52: // i64.ne
			fn.cmpOp(token.NEQ)
		case 0x53: // i64.lt_s
			fn.cmpOp(token.LSS)
		case 0x54: // i64.lt_u
			fn.cmpOpU64(token.LSS)
		case 0x55: // i64.gt_s
			fn.cmpOp(token.GTR)
		case 0x56: // i64.gt_u
			fn.cmpOpU64(token.GTR)
		case 0x57: // i64.le_s
			fn.cmpOp(token.LEQ)
		case 0x58: // i64.le_u
			fn.cmpOpU64(token.LEQ)
		case 0x59: // i64.ge_s
			fn.cmpOp(token.GEQ)
		case 0x5a: // i64.ge_u
			fn.cmpOpU64(token.GEQ)

		case 0x5b: // f32.eq
			fn.cmpOp(token.EQL)
		case 0x5c: // f32.ne
			fn.cmpOp(token.NEQ)
		case 0x5d: // f32.lt
			fn.cmpOp(token.LSS)
		case 0x5e: // f32.gt
			fn.cmpOp(token.GTR)
		case 0x5f: // f32.le
			fn.cmpOp(token.LEQ)
		case 0x60: // f32.ge
			fn.cmpOp(token.GEQ)

		case 0x61: // f64.eq
			fn.cmpOp(token.EQL)
		case 0x62: // f64.ne
			fn.cmpOp(token.NEQ)
		case 0x63: // f64.lt
			fn.cmpOp(token.LSS)
		case 0x64: // f64.gt
			fn.cmpOp(token.GTR)
		case 0x65: // f64.le
			fn.cmpOp(token.LEQ)
		case 0x66: // f64.ge
			fn.cmpOp(token.GEQ)

		case 0x67: // i32.clz
			fn.bitOp("LeadingZeros32")
		case 0x68: // i32.ctz
			fn.bitOp("TrailingZeros32")
		case 0x69: // i32.popcnt
			fn.bitOp("OnesCount32")
		case 0x6a: // i32.add
			fn.binOp(token.ADD)
		case 0x6b: // i32.sub
			fn.binOp(token.SUB)
		case 0x6c: // i32.mul
			fn.binOp(token.MUL)
		case 0x6d: // i32.div_s
			fn.binHelper("i32_div_s", "math")
		case 0x6e: // i32.div_u
			fn.binOpU32(token.QUO)
		case 0x6f: // i32.rem_s
			fn.binOp(token.REM)
		case 0x70: // i32.rem_u
			fn.binOpU32(token.REM)
		case 0x71: // i32.and
			fn.binOp(token.AND)
		case 0x72: // i32.or
			fn.binOp(token.OR)
		case 0x73: // i32.xor
			fn.binOp(token.XOR)
		case 0x74: // i32.shl
			fn.binHelper("i32_shl")
		case 0x75: // i32.shr_s
			fn.binHelper("i32_shr_s")
		case 0x76: // i32.shr_u
			fn.binHelper("i32_shr_u")
		case 0x77: // i32.rotl
			fn.binHelper("i32_rotl", "bits")
		case 0x78: // i32.rotr
			fn.binHelper("i32_rotr", "bits")

		case 0x79: // i64.clz
			fn.bitOp("LeadingZeros64")
		case 0x7a: // i64.ctz
			fn.bitOp("TrailingZeros64")
		case 0x7b: // i64.popcnt
			fn.bitOp("OnesCount64")
		case 0x7c: // i64.add
			fn.binOp(token.ADD)
		case 0x7d: // i64.sub
			fn.binOp(token.SUB)
		case 0x7e: // i64.mul
			fn.binOp(token.MUL)
		case 0x7f: // i64.div_s
			fn.binHelper("i64_div_s", "math")
		case 0x80: // i64.div_u
			fn.binOpU64(token.QUO)
		case 0x81: // i64.rem_s
			fn.binOp(token.REM)
		case 0x82: // i64.rem_u
			fn.binOpU64(token.REM)
		case 0x83: // i64.and
			fn.binOp(token.AND)
		case 0x84: // i64.or
			fn.binOp(token.OR)
		case 0x85: // i64.xor
			fn.binOp(token.XOR)
		case 0x86: // i64.shl
			fn.binHelper("i64_shl")
		case 0x87: // i64.shr_s
			fn.binHelper("i64_shr_s")
		case 0x88: // i64.shr_u
			fn.binHelper("i64_shr_u")
		case 0x89: // i64.rotl
			fn.binHelper("i64_rotl", "bits")
		case 0x8a: // i64.rotr
			fn.binHelper("i64_rotr", "bits")

		case 0x8b: // f32.abs
			fn.uniMath32("Abs")
		case 0x8c: // f32.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x8d: // f32.ceil
			fn.uniMath32("Ceil")
		case 0x8e: // f32.floor
			fn.uniMath32("Floor")
		case 0x8f: // f32.trunc
			fn.uniMath32("Trunc")
		case 0x90: // f32.nearest
			fn.uniMath32("RoundToEven")
		case 0x91: // f32.sqrt
			fn.uniMath32("Sqrt")
		case 0x92: // f32.add
			fn.binOpF32(token.ADD)
		case 0x93: // f32.sub
			fn.binOpF32(token.SUB)
		case 0x94: // f32.mul
			fn.binOpF32(token.MUL)
		case 0x95: // f32.div
			fn.binOpF32(token.QUO) // go.dev/issue/43577
		case 0x96: // f32.min
			fn.binBuiltin("min")
		case 0x97: // f32.max
			fn.binBuiltin("max")
		case 0x98: // f32.copysign
			fn.binMath32("Copysign")

		case 0x99: // f64.abs
			fn.uniMath64("Abs")
		case 0x9a: // f64.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x9b: // f64.ceil
			fn.uniMath64("Ceil")
		case 0x9c: // f64.floor
			fn.uniMath64("Floor")
		case 0x9d: // f64.trunc
			fn.uniMath64("Trunc")
		case 0x9e: // f64.nearest
			fn.uniMath64("RoundToEven")
		case 0x9f: // f64.sqrt
			fn.uniMath64("Sqrt")
		case 0xa0: // f64.add
			fn.binOpF64(token.ADD)
		case 0xa1: // f64.sub
			fn.binOpF64(token.SUB)
		case 0xa2: // f64.mul
			fn.binOpF64(token.MUL)
		case 0xa3: // f64.div
			fn.binOpF64(token.QUO) // go.dev/issue/43577
		case 0xa4: // f64.min
			fn.binBuiltin("min")
		case 0xa5: // f64.max
			fn.binBuiltin("max")
		case 0xa6: // f64.copysign
			fn.binMath64("Copysign")

		case 0xa7: // i32.wrap_i64
			fn.convert("int32")

		case 0xa8: // i32.trunc_f32_s
			fn.uniHelper("i32_trunc_f32_s")
		case 0xa9: // i32.trunc_f32_u
			fn.uniHelper("i32_trunc_f32_u")
		case 0xaa: // i32.trunc_f64_s
			fn.uniHelper("i32_trunc_f64_s")
		case 0xab: // i32.trunc_f64_u
			fn.uniHelper("i32_trunc_f64_u")

		case 0xac: // i64.extend_i32_s
			fn.convert("int64")
		case 0xad: // i64.extend_i32_u
			fn.convert("uint32", "int64")

		case 0xae: // i64.trunc_f32_s
			fn.uniHelper("i64_trunc_f32_s")
		case 0xaf: // i64.trunc_f32_u
			fn.uniHelper("i64_trunc_f32_u")
		case 0xb0: // i64.trunc_f64_s
			fn.uniHelper("i64_trunc_f64_s")
		case 0xb1: // i64.trunc_f64_u
			fn.uniHelper("i64_trunc_f64_u")

		case 0xb2: // f32.convert_i32_s
			fn.convert("float32")
		case 0xb3: // f32.convert_i32_u
			fn.convert("uint32", "float32")
		case 0xb4: // f32.convert_i64_s
			fn.convert("float32")
		case 0xb5: // f32.convert_i64_u
			fn.convert("uint64", "float32")
		case 0xb6: // f32.demote_f64
			fn.convert("float32")

		case 0xb7: // f64.convert_i32_s
			fn.convert("float64")
		case 0xb8: // f64.convert_i32_u
			fn.convert("uint32", "float64")
		case 0xb9: // f64.convert_i64_s
			fn.convert("float64")
		case 0xba: // f64.convert_i64_u
			fn.convert("uint64", "float64")
		case 0xbb: // f64.promote_f32
			fn.convert("float64")

		case 0xbc: // i32.reinterpret_f32
			fn.float32bits()
		case 0xbd: // i64.reinterpret_f64
			fn.float64bits()
		case 0xbe: // f32.reinterpret_i32
			fn.float32frombits()
		case 0xbf: // f64.reinterpret_i64
			fn.float64frombits()

		case 0xfc:
			code, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			switch code {
			case 0x00: // i32.trunc_sat_f32_s
				fn.uniHelper("i32_trunc_sat_f32_s")
			case 0x01: // i32.trunc_sat_f32_u
				fn.uniHelper("i32_trunc_sat_f32_u")
			case 0x02: // i32.trunc_sat_f64_s
				fn.uniHelper("i32_trunc_sat_f64_s")
			case 0x03: // i32.trunc_sat_f64_u
				fn.uniHelper("i32_trunc_sat_f64_u")
			case 0x04: // i64.trunc_sat_f32_s
				fn.uniHelper("i64_trunc_sat_f32_s")
			case 0x05: // i64.trunc_sat_f32_u
				fn.uniHelper("i64_trunc_sat_f32_u")
			case 0x06: // i64.trunc_sat_f64_s
				fn.uniHelper("i64_trunc_sat_f64_s")
			case 0x07: // i64.trunc_sat_f64_u
				fn.uniHelper("i64_trunc_sat_f64_u")
			default:
				return fmt.Errorf("unsupported opcode: 0xfc %02x", code)
			}

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

var modRecvList = &ast.FieldList{List: []*ast.Field{{
	Names: []*ast.Ident{newID("m")},
	Type:  newID("Module"),
}}}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: newID("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{newID("memory")},
								Type: &ast.ArrayType{
									Elt: newID("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}
