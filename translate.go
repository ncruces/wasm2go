package main

import (
	"bufio"
	"encoding/binary"
	"errors"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"slices"
)

type translator struct {
	in  *bufio.Reader
	out ast.File

	types []funcType
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = ast.NewIdent(name)

	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	t.out.Decls = append(t.out.Decls, createModuleStruct())

	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, token.NewFileSet(), &t.out)
	return out.Flush()
}

type funcType struct {
	params  string
	results string
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

type wasmType byte

const (
	i32 wasmType = 0x7f
	i64 wasmType = 0x7e
	f32 wasmType = 0x7d
	f64 wasmType = 0x7c
)

func (t translator) skipSection() error {
	size, err := readLEB128(t.in)
	if err != nil {
		return err
	}
	_, err = t.in.Discard(int(size))
	return err
}

func (t *translator) readSection() error {
	b, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	switch sectionID(b) {
	case sectionType:
		return t.readTypeSection()
	default:
		return t.skipSection()
	}
}

func (t *translator) readTypeSection() error {
	// Read the size of the Type section.
	_, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	types, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var buf []byte
	t.types = make([]funcType, types)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			fmt.Printf("form: %x\n", form)
			return errors.New("only function types are supported")
		}

		// Parse parameters
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		buf = slices.Grow(buf[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, buf)
		if err != nil {
			return err
		}
		t.types[i].params = string(buf)

		// Parse results
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		buf = slices.Grow(buf[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, buf)
		if err != nil {
			return err
		}
		t.types[i].results = string(buf)
	}
	return nil
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if string(header[:4]) != "\x00asm" {
		return errors.New("invalid magic number")
	}
	if binary.LittleEndian.Uint32(header[4:]) != 1 {
		return errors.New("invalid version")
	}
	return nil
}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("memory")},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}
