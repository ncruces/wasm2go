package main

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"log"
	"slices"
)

type translator struct {
	in  *bufio.Reader
	out ast.File

	types     []funcType
	functions []funcRef
	exports   map[string]export
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = ast.NewIdent(name)
	t.out.Decls = append(t.out.Decls, createModuleStruct())

	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, token.NewFileSet(), &t.out)
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	_, err = readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionExport:
		return t.readExportSection()
	case sectionCode:
		return t.readCodeSection()
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

type wasmType byte

const (
	i32 wasmType = 127 - iota
	i64
	f32
	f64
)

func (t wasmType) String() string {
	switch t {
	case i32:
		return "int32"
	case i64:
		return "int64"
	case f32:
		return "float32"
	case f64:
		return "float64"
	}
	panic(fmt.Sprintf("unsupported type: %x", byte(t)))
}

type funcType struct {
	params  string // wasmType of parameters
	results string // wasmType of results
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var types []byte
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].params = string(types)

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].results = string(types)
	}
	return nil
}

type funcRef struct {
	decl *ast.FuncDecl
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.functions = make([]funcRef, numFuncs)
	for i := range t.functions {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		decl := &ast.FuncDecl{
			Recv: &ast.FieldList{List: []*ast.Field{{
				Names: []*ast.Ident{ast.NewIdent("m")},
				Type:  ast.NewIdent("Module"),
			}}},
			Type: makeFuncType(t.types[index]),
		}
		t.out.Decls = append(t.out.Decls, decl)
		t.functions[i].decl = decl
	}
	return nil
}

func makeFuncType(t funcType) *ast.FuncType {
	params := makeFieldList(t.params)
	results := makeFieldList(t.results)
	if params == nil {
		params = &ast.FieldList{}
	}
	return &ast.FuncType{Params: params, Results: results}
}

func makeFieldList(types string) *ast.FieldList {
	if len(types) == 0 {
		return nil
	}
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		name := wasmType(t).String()
		list[i] = &ast.Field{
			Type: ast.NewIdent(name),
		}
	}
	return &ast.FieldList{List: list}
}

type exportKind byte

const (
	functionExport exportKind = iota
	tableExport
	memoryExport
	globalExport
)

type export struct {
	kind  exportKind
	index int
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var names []byte
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		names = slices.Grow(names[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, names)
		if err != nil {
			return err
		}

		name := string(names)
		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			if decl := t.functions[index].decl; decl.Name == nil {
				decl.Name = ast.NewIdent(exported(name))
			}
		}
	}
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		log.Printf("Code for function %d", i)
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		numLocals, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		for range numLocals {
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			typ, err := t.in.ReadByte()
			if err != nil {
				return err
			}
			log.Printf("  Local: %d x %v", n, wasmType(typ))
		}

		for depth := 1; depth > 0; {
			opcode, err := t.in.ReadByte()
			if err != nil {
				return err
			}

			switch opcode {
			case 0x02, 0x03, 0x04: // block, loop, if
				depth++
				bt, err := t.readBlockType()
				if err != nil {
					return err
				}
				var name string
				switch opcode {
				case 0x02:
					name = "block"
				case 0x03:
					name = "loop"
				case 0x04:
					name = "if"
				}
				log.Printf("  %s %#v", name, bt)
			case 0x05: // else
				log.Println("  else")
			case 0x0b: // end
				depth--
				log.Println("  end")
			case 0x0c: // br
				idx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				log.Printf("  br %d", idx)
			case 0x1b: // select
				log.Println("  select")
			case 0x20: // local.get
				idx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				log.Printf("  local.get %d", idx)
			case 0x21: // local.set
				idx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				log.Printf("  local.set %d", idx)
			case 0x22: // local.tee
				idx, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				log.Printf("  local.tee %d", idx)
			case 0x41: // i32.const
				val, err := readSignedLEB128(t.in)
				if err != nil {
					return err
				}
				log.Printf("  i32.const %d", val)
			case 0x4a: // i32.gt_s
				log.Println("  i32.gt_s")
			case 0x6a: // i32.add
				log.Println("  i32.add")
			case 0x6b: // i32.sub
				log.Println("  i32.sub")
			default:
				return fmt.Errorf("unsupported opcode: %x", opcode)
			}
		}
	}
	return nil
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("memory")},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}
