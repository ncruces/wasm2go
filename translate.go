package main

import (
	"bufio"
	_ "embed"
	"encoding/binary"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"slices"
	"strconv"
)

var (
	int32Ident   = ast.NewIdent("int32")
	int64Ident   = ast.NewIdent("int64")
	uint32Ident  = ast.NewIdent("uint32")
	uint64Ident  = ast.NewIdent("uint64")
	float32Ident = ast.NewIdent("float32")
	float64Ident = ast.NewIdent("float64")
	modTypIdent  = ast.NewIdent("Module")
	modVarIdent  = ast.NewIdent("m")
	modRecvList  = &ast.FieldList{List: []*ast.Field{{
		Names: []*ast.Ident{modVarIdent},
		Type:  modTypIdent,
	}}}
)

//go:embed helpers/helpers.go
var helpersSrc string

type translator struct {
	in  *bufio.Reader
	out ast.File

	types     []funcType
	functions []funcRef
	exports   map[string]export
	packages  set[string]
	helpers   set[string]
}

func translate(name string, r io.Reader, w io.Writer) error {
	var t translator

	t.in = bufio.NewReader(r)
	err := readHeader(t.in)
	if err != nil {
		return err
	}

	t.out.Name = ast.NewIdent(name)
	t.out.Decls = append(t.out.Decls, createModuleStruct())

	t.packages = set[string]{}
	t.helpers = set[string]{}

	for {
		if err := t.readSection(); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
	}

	for pkg := range t.packages {
		t.out.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"` + pkg + `"`},
			}},
		}}, t.out.Decls...)
	}

	fset := token.NewFileSet()
	if len(t.helpers) > 0 {
		f, err := parser.ParseFile(fset, "helpers.go", helpersSrc, 0)
		if err != nil {
			return err
		}
		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && t.helpers.has(fn.Name.Name) {
				t.out.Decls = append(t.out.Decls, decl)
			}
		}
	}

	out := bufio.NewWriter(w)
	out.WriteString("// Code generated by wasm2go. DO NOT EDIT.\n\n")
	printer.Fprint(out, fset, &t.out)
	return out.Flush()
}

type sectionID byte

const (
	sectionCustom sectionID = iota
	sectionType
	sectionImport
	sectionFunction
	sectionTable
	sectionMemory
	sectionGlobal
	sectionExport
	sectionStart
	sectionElement
	sectionCode
	sectionData
	sectionDataCount
)

func (t *translator) readSection() error {
	id, err := t.in.ReadByte()
	if err != nil {
		return err
	}

	_, err = readLEB128(t.in)
	if err != nil {
		return err
	}

	switch sectionID(id) {
	case sectionType:
		return t.readTypeSection()
	case sectionFunction:
		return t.readFunctionSection()
	case sectionExport:
		return t.readExportSection()
	case sectionCode:
		return t.readCodeSection()
	default:
		return fmt.Errorf("skipped section: %d", id)
	}
}

type wasmType byte

const (
	i32 wasmType = 127 - iota
	i64
	f32
	f64
)

func (t wasmType) String() string {
	switch t {
	case i32:
		return "int32"
	case i64:
		return "int64"
	case f32:
		return "float32"
	case f64:
		return "float64"
	}
	panic(fmt.Sprintf("unsupported type: %x", byte(t)))
}

type funcType struct {
	params  string // wasmType of parameters
	results string // wasmType of results
}

func (t *translator) readTypeSection() error {
	numTypes, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var types []byte
	t.types = make([]funcType, numTypes)
	for i := range t.types {
		form, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		if form != 0x60 {
			return fmt.Errorf("unsupported form: %x", form)
		}

		// Parse parameter types.
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].params = string(types)

		// Parse result types.
		n, err = readLEB128(t.in)
		if err != nil {
			return err
		}

		types = slices.Grow(types[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, types)
		if err != nil {
			return err
		}
		t.types[i].results = string(types)
	}
	return nil
}

type funcRef struct {
	typ  funcType
	decl *ast.FuncDecl
	pkgs set[string]
	hlps set[string]

	top    ast.Expr
	cond   ast.Expr
	stack  []ast.Expr
	blocks []block
	labels int
	temps  int
}

// Pushes expr (a literal, constant or materialized temporary) to the value stack.
func (fn *funcRef) pushConst(expr ast.Expr) {
	fn.stack = append(fn.stack, expr)
	fn.cond = nil
	fn.top = nil
}

// Pushes the materialization of expr to the value stack.
func (fn *funcRef) push(expr ast.Expr) {
	tmp := fn.makeTempVar()
	blk := &fn.blocks[len(fn.blocks)-1]
	blk.append(&ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{tmp},
		Rhs: []ast.Expr{expr},
	})
	fn.pushConst(tmp)
	fn.top = expr
}

// Pushes the integer materialization of cond the value stack.
func (fn *funcRef) pushCond(cond ast.Expr) {
	tmp := fn.makeTempVar()
	blk := &fn.blocks[len(fn.blocks)-1]
	blk.append(&ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok: token.VAR,
			Specs: []ast.Spec{
				&ast.ValueSpec{
					Names: []*ast.Ident{tmp},
					Type:  int32Ident,
				},
			},
		},
	}, &ast.IfStmt{
		Cond: cond,
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Tok: token.ASSIGN,
					Lhs: []ast.Expr{tmp},
					Rhs: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: "1"}},
				},
			},
		},
	})
	fn.pushConst(tmp)
	fn.cond = cond
}

// Pops a materialized value from the value stack.
func (fn *funcRef) popCopy() ast.Expr {
	expr := pop(&fn.stack)
	fn.cond = nil
	fn.top = nil
	return expr
}

// Pops a (possibly unevaluated) value from the value stack.
// The value must be immediately used once and only once.
func (fn *funcRef) pop() ast.Expr {
	expr := pop(&fn.stack)
	top := fn.top
	fn.cond = nil
	fn.top = nil
	if top == nil {
		return expr
	}

	pop(&fn.blocks[len(fn.blocks)-1].body.List)
	return top
}

// Pops a (possibly unevaluated) condition from the value stack.
// The condition must be immediately used once and only once.
func (fn *funcRef) popCond() ast.Expr {
	expr := pop(&fn.stack)
	cond := fn.cond
	fn.cond = nil
	fn.top = nil
	if cond == nil {
		return &ast.BinaryExpr{
			X: expr, Op: token.NEQ,
			Y: &ast.BasicLit{Kind: token.INT, Value: "0"},
		}
	}

	pop(&fn.blocks[len(fn.blocks)-1].body.List)
	pop(&fn.blocks[len(fn.blocks)-1].body.List)
	return cond
}

type block struct {
	typ         funcType
	body        *ast.BlockStmt
	ifStmt      *ast.IfStmt
	results     []*ast.Ident
	label       *ast.Ident
	loopPos     int
	unreachable bool
}

func (b *block) append(stmts ...ast.Stmt) {
	lst := &b.body.List
	*lst = append(*lst, stmts...)
}

func (b *block) setResults(fn *funcRef) {
	if !b.unreachable {
		for i := len(b.results) - 1; i >= 0; i-- {
			b.append(&ast.AssignStmt{
				Lhs: []ast.Expr{b.results[i]},
				Rhs: []ast.Expr{fn.pop()},
				Tok: token.ASSIGN,
			})
		}
	}
}

func (t *translator) readFunctionSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	t.functions = make([]funcRef, numFuncs)
	for i := range t.functions {
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		fn := &t.functions[i]
		fn.typ = t.types[index]
		fn.pkgs = t.packages
		fn.hlps = t.helpers
		fn.decl = &ast.FuncDecl{
			Type: makeFuncType(fn.typ),
			Recv: modRecvList,
		}
		t.out.Decls = append(t.out.Decls, fn.decl)
	}
	return nil
}

func makeFuncType(t funcType) *ast.FuncType {
	return &ast.FuncType{
		Params:  makeParamsList(t.params),
		Results: makeResultsList(t.results),
	}
}

func makeParamsList(types string) *ast.FieldList {
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(local(i))},
			Type:  ast.NewIdent(wasmType(t).String()),
		}
	}
	return &ast.FieldList{List: list}
}

func makeResultsList(types string) *ast.FieldList {
	if len(types) == 0 {
		return nil
	}
	list := make([]*ast.Field, len(types))
	for i, t := range []byte(types) {
		list[i] = &ast.Field{Type: ast.NewIdent(wasmType(t).String())}
	}
	return &ast.FieldList{List: list}
}

type exportKind byte

const (
	functionExport exportKind = iota
	tableExport
	memoryExport
	globalExport
)

type export struct {
	kind  exportKind
	index int
}

func (t *translator) readExportSection() error {
	numExports, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	var names []byte
	t.exports = make(map[string]export, numExports)
	for range numExports {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		names = slices.Grow(names[:0], int(n))[:n]
		_, err = io.ReadFull(t.in, names)
		if err != nil {
			return err
		}

		name := string(names)
		kind, err := t.in.ReadByte()
		if err != nil {
			return err
		}
		index, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		t.exports[name] = export{
			kind:  exportKind(kind),
			index: int(index),
		}

		switch exportKind(kind) {
		case functionExport:
			if decl := t.functions[index].decl; decl.Name == nil {
				decl.Name = ast.NewIdent(exported(name))
			}
		}
	}
	return nil
}

func (t *translator) readCodeSection() error {
	numFuncs, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	for i := range numFuncs {
		_, err := readLEB128(t.in)
		if err != nil {
			return err
		}

		err = t.readCodeForFunction(&t.functions[i])
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *translator) readCodeForFunction(fn *funcRef) error {
	body := &ast.BlockStmt{}
	fn.decl.Body = body
	fn.blocks = []block{{body: body}}

	numVars, err := readLEB128(t.in)
	if err != nil {
		return err
	}

	// Declare local variables.
	// Parameters are predeclared locals.
	numLocals := len(fn.typ.params)
	for range numVars {
		n, err := readLEB128(t.in)
		if err != nil {
			return err
		}
		typ, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		names := make([]*ast.Ident, int(n))
		for i := range int(n) {
			names[i] = ast.NewIdent(local(numLocals))
			numLocals++
		}
		body.List = append(body.List, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: names,
						Type:  ast.NewIdent(wasmType(typ).String()),
					},
				},
			},
		})
	}

	for {
		opcode, err := t.in.ReadByte()
		if err != nil {
			return err
		}

		blk := &fn.blocks[len(fn.blocks)-1]

		switch opcode {
		case 0x02, 0x03, 0x04: // block, loop, if
			bt, err := t.readBlockType()
			if err != nil {
				return err
			}

			var cond ast.Expr
			if opcode == 0x04 { // if
				cond = fn.popCond()
			}

			// Declare block results outside the block.
			results := make([]*ast.Ident, len(bt.results))
			for i, t := range []byte(bt.results) {
				results[i] = fn.makeTempVar()
				blk.append(&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{results[i]},
								Type:  ast.NewIdent(wasmType(t).String()),
							},
						},
					},
				})
			}

			childBlk := block{
				typ:     bt,
				body:    &ast.BlockStmt{},
				results: results,
			}

			var stmt ast.Stmt
			switch opcode {
			case 0x02: // block
				stmt = childBlk.body

			case 0x03: // loop
				// Remember the loop start position.
				// Bitwise not makes the zero value useful (not a loop).
				childBlk.loopPos = ^len(blk.body.List)
				stmt = childBlk.body

			case 0x04: // if
				// We need to remember the if statement
				// so we can attach an else branch.
				childBlk.ifStmt = &ast.IfStmt{Cond: cond, Body: childBlk.body}
				stmt = childBlk.ifStmt
			}

			fn.blocks = append(fn.blocks, childBlk)
			blk.append(stmt)

		case 0x05: // else
			// Set the results of the if branch.
			blk.setResults(fn)
			// Create a new block at the same level,
			// make it the else branch.
			blk.body = &ast.BlockStmt{}
			blk.ifStmt.Else = blk.body
			blk.unreachable = false

		case 0x0b: // end
			if len(fn.blocks) == 1 { // End of the function body.
				if !blk.unreachable && len(fn.typ.results) > 0 {
					ret := &ast.ReturnStmt{}
					ret.Results = make([]ast.Expr, len(fn.typ.results))
					for i := len(ret.Results) - 1; i >= 0; i-- {
						ret.Results[i] = fn.pop()
					}
					blk.append(ret)
				}
				return nil
			}

			// Set block results, but push them again
			// so they're available to the parent block.
			blk.setResults(fn)
			for _, val := range blk.results {
				fn.pushConst(val)
			}

			pop(&fn.blocks)
			if blk.label != nil { // Add the label if requested.
				parent := &fn.blocks[len(fn.blocks)-1]
				if blk.loopPos != 0 { // At the start for loops.
					parent.body.List[^blk.loopPos] = &ast.LabeledStmt{
						Stmt:  parent.body.List[^blk.loopPos],
						Label: blk.label,
					}
				} else { // At the end for other block types.
					parent.append(&ast.LabeledStmt{
						Stmt:  &ast.EmptyStmt{},
						Label: blk.label,
					})
				}
			}

		case 0x0c: // br
			// How many nested blocks are we exiting?
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			n = uint64(len(fn.blocks)) - n - 1

			blk.append(fn.branch(n))
			blk.unreachable = true // After an uncoditional goto.

		case 0x0d: // br_if
			// How many nested blocks would we exit?
			n, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			n = uint64(len(fn.blocks)) - n - 1

			// Conditional break.
			blk.append(&ast.IfStmt{
				Cond: fn.popCond(),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{fn.branch(n)},
				},
			})

		case 0x0e: // br_table
			numTargets, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			targets := make([]uint64, numTargets)
			for i := range targets {
				target, err := readLEB128(t.in)
				if err != nil {
					return err
				}
				targets[i] = uint64(len(fn.blocks)) - target - 1
			}
			defaultTarget, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			defaultTarget = uint64(len(fn.blocks)) - defaultTarget - 1

			sw := &ast.SwitchStmt{Tag: fn.pop(), Body: &ast.BlockStmt{
				List: []ast.Stmt{&ast.CaseClause{
					Body: []ast.Stmt{fn.branch(defaultTarget)},
				}},
			}}
			for i, target := range targets {
				sw.Body.List = append(sw.Body.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(i)}},
					Body: []ast.Stmt{fn.branch(target)},
				})
			}
			blk.append(sw)
			blk.unreachable = true // After switch.

		case 0x0f: // return
			ret := &ast.ReturnStmt{}
			if len(fn.typ.results) > 0 {
				ret.Results = make([]ast.Expr, len(fn.typ.results))
				for i := len(ret.Results) - 1; i >= 0; i-- {
					ret.Results[i] = fn.pop()
				}
			}
			blk.append(ret)
			blk.unreachable = true // After an uncoditional return.

		case 0x1b: // select
			cond := fn.popCond()
			val := fn.makeTempVar()
			blk.append(&ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{val},
				Rhs: []ast.Expr{fn.pop()},
			}, &ast.IfStmt{
				Cond: cond,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Tok: token.ASSIGN,
							Lhs: []ast.Expr{val},
							Rhs: []ast.Expr{fn.popCopy()}, // must eval
						},
					},
				},
			})
			fn.pushConst(val)

		case 0x20: // local.get
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			fn.push(ast.NewIdent(local(i)))

		case 0x21: // local.set
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent(local(i))},
				Rhs: []ast.Expr{fn.pop()},
				Tok: token.ASSIGN,
			})

		case 0x22: // local.tee
			i, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			val := fn.popCopy() // will be reused
			blk.append(&ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent(local(i))},
				Rhs: []ast.Expr{val},
				Tok: token.ASSIGN,
			})
			fn.pushConst(val)

		case 0x41: // i32.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushConst(&ast.CallExpr{
				Fun: int32Ident,
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x42: // i64.const
			i, err := readSignedLEB128(t.in)
			if err != nil {
				return err
			}
			fn.pushConst(&ast.CallExpr{
				Fun: int64Ident,
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatInt(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x43: // f32.const
			var i uint32
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.pkgs.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("math"),
					Sel: ast.NewIdent("Float32frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(uint64(i), 10),
					Kind:  token.INT,
				}},
			})

		case 0x44: // f64.const
			var i uint64
			if err := binary.Read(t.in, binary.LittleEndian, &i); err != nil {
				return err
			}
			fn.pkgs.add("math")
			fn.pushConst(&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("math"),
					Sel: ast.NewIdent("Float64frombits"),
				},
				Args: []ast.Expr{&ast.BasicLit{
					Value: strconv.FormatUint(i, 10),
					Kind:  token.INT,
				}},
			})

		case 0x45: // i32.eqz
			fn.eqzOp()
		case 0x46: // i32.eq
			fn.cmpOp(token.EQL)
		case 0x47: // i32.ne
			fn.cmpOp(token.NEQ)
		case 0x48: // i32.lt_s
			fn.cmpOp(token.LSS)
		case 0x49: // i32.lt_u
			fn.cmpOpU32(token.LSS)
		case 0x4a: // i32.gt_s
			fn.cmpOp(token.GTR)
		case 0x4b: // i32.gt_u
			fn.cmpOpU32(token.GTR)
		case 0x4c: // i32.le_s
			fn.cmpOp(token.LEQ)
		case 0x4d: // i32.le_u
			fn.cmpOpU32(token.LEQ)
		case 0x4e: // i32.ge_s
			fn.cmpOp(token.GEQ)
		case 0x4f: // i32.ge_u
			fn.cmpOpU32(token.GEQ)

		case 0x50: // i64.eqz
			fn.eqzOp()
		case 0x51: // i64.eq
			fn.cmpOp(token.EQL)
		case 0x52: // i64.ne
			fn.cmpOp(token.NEQ)
		case 0x53: // i64.lt_s
			fn.cmpOp(token.LSS)
		case 0x54: // i64.lt_u
			fn.cmpOpU64(token.LSS)
		case 0x55: // i64.gt_s
			fn.cmpOp(token.GTR)
		case 0x56: // i64.gt_u
			fn.cmpOpU64(token.GTR)
		case 0x57: // i64.le_s
			fn.cmpOp(token.LEQ)
		case 0x58: // i64.le_u
			fn.cmpOpU64(token.LEQ)
		case 0x59: // i64.ge_s
			fn.cmpOp(token.GEQ)
		case 0x5a: // i64.ge_u
			fn.cmpOpU64(token.GEQ)

		case 0x5b: // f32.eq
			fn.cmpOp(token.EQL)
		case 0x5c: // f32.ne
			fn.cmpOp(token.NEQ)
		case 0x5d: // f32.lt
			fn.cmpOp(token.LSS)
		case 0x5e: // f32.gt
			fn.cmpOp(token.GTR)
		case 0x5f: // f32.le
			fn.cmpOp(token.LEQ)
		case 0x60: // f32.ge
			fn.cmpOp(token.GEQ)

		case 0x61: // f64.eq
			fn.cmpOp(token.EQL)
		case 0x62: // f64.ne
			fn.cmpOp(token.NEQ)
		case 0x63: // f64.lt
			fn.cmpOp(token.LSS)
		case 0x64: // f64.gt
			fn.cmpOp(token.GTR)
		case 0x65: // f64.le
			fn.cmpOp(token.LEQ)
		case 0x66: // f64.ge
			fn.cmpOp(token.GEQ)

		case 0x67: // i32.clz
			fn.bitOp("LeadingZeros32", int32Ident, uint32Ident)
		case 0x68: // i32.ctz
			fn.bitOp("TrailingZeros32", int32Ident, uint32Ident)
		case 0x69: // i32.popcnt
			fn.bitOp("OnesCount32", int32Ident, uint32Ident)
		case 0x6a: // i32.add
			fn.binOp(token.ADD)
		case 0x6b: // i32.sub
			fn.binOp(token.SUB)
		case 0x6c: // i32.mul
			fn.binOp(token.MUL)
		case 0x6d: // i32.div_s
			fn.binOp(token.QUO)
		case 0x6e: // i32.div_u
			fn.binOpU32(token.QUO)
		case 0x6f: // i32.rem_s
			fn.binOp(token.REM)
		case 0x70: // i32.rem_u
			fn.binOpU32(token.REM)
		case 0x71: // i32.and
			fn.binOp(token.AND)
		case 0x72: // i32.or
			fn.binOp(token.OR)
		case 0x73: // i32.xor
			fn.binOp(token.XOR)
		case 0x74: // i32.shl
			fn.binOp(token.SHL)
		case 0x75: // i32.shr_s
			fn.binOp(token.SHR)
		case 0x76: // i32.shr_u
			fn.binOpU32(token.SHR)
		case 0x77, 0x78: // i32.rotl, i32.rotr
			fn.rotOp("RotateLeft32", opcode == 0x77, int32Ident, uint32Ident)

		case 0x79: // i64.clz
			fn.bitOp("LeadingZeros64", int64Ident, uint64Ident)
		case 0x7a: // i64.ctz
			fn.bitOp("TrailingZeros64", int64Ident, uint64Ident)
		case 0x7b: // i64.popcnt
			fn.bitOp("OnesCount64", int64Ident, uint64Ident)
		case 0x7c: // i64.add
			fn.binOp(token.ADD)
		case 0x7d: // i64.sub
			fn.binOp(token.SUB)
		case 0x7e: // i64.mul
			fn.binOp(token.MUL)
		case 0x7f: // i64.div_s
			fn.binOp(token.QUO)
		case 0x80: // i64.div_u
			fn.binOpU64(token.QUO)
		case 0x81: // i64.rem_s
			fn.binOp(token.REM)
		case 0x82: // i64.rem_u
			fn.binOpU64(token.REM)
		case 0x83: // i64.and
			fn.binOp(token.AND)
		case 0x84: // i64.or
			fn.binOp(token.OR)
		case 0x85: // i64.xor
			fn.binOp(token.XOR)
		case 0x86: // i64.shl
			fn.binOp(token.SHL)
		case 0x87: // i64.shr_s
			fn.binOp(token.SHR)
		case 0x88: // i64.shr_u
			fn.binOpU64(token.SHR)
		case 0x89, 0x8a: // i64.rotl, i64.rotr
			fn.rotOp("RotateLeft64", opcode == 0x89, int64Ident, uint64Ident)

		case 0x8b: // f32.abs
			fn.uniMath32("Abs")
		case 0x8c: // f32.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x8d: // f32.ceil
			fn.uniMath32("Ceil")
		case 0x8e: // f32.floor
			fn.uniMath32("Floor")
		case 0x8f: // f32.trunc
			fn.uniMath32("Trunc")
		case 0x90: // f32.nearest
			fn.uniMath32("RoundToEven")
		case 0x91: // f32.sqrt
			fn.uniMath32("Sqrt")
		case 0x92: // f32.add
			fn.binOp(token.ADD)
		case 0x93: // f32.sub
			fn.binOp(token.SUB)
		case 0x94: // f32.mul
			fn.binOp(token.MUL)
		case 0x95: // f32.div
			fn.binOp(token.QUO)
		case 0x96: // f32.min
			fn.binBuiltin("min")
		case 0x97: // f32.max
			fn.binBuiltin("max")
		case 0x98: // f32.copysign
			fn.binMath32("Copysign")

		case 0x99: // f64.abs
			fn.uniMath("Abs")
		case 0x9a: // f64.neg
			fn.push(&ast.UnaryExpr{Op: token.SUB, X: fn.pop()})
		case 0x9b: // f64.ceil
			fn.uniMath("Ceil")
		case 0x9c: // f64.floor
			fn.uniMath("Floor")
		case 0x9d: // f64.trunc
			fn.uniMath("Trunc")
		case 0x9e: // f64.nearest
			fn.uniMath("RoundToEven")
		case 0x9f: // f64.sqrt
			fn.uniMath("Sqrt")
		case 0xa0: // f64.add
			fn.binOp(token.ADD)
		case 0xa1: // f64.sub
			fn.binOp(token.SUB)
		case 0xa2: // f64.mul
			fn.binOp(token.MUL)
		case 0xa3: // f64.div
			fn.binOp(token.QUO)
		case 0xa4: // f64.min
			fn.binBuiltin("min")
		case 0xa5: // f64.max
			fn.binBuiltin("max")
		case 0xa6: // f64.copysign
			fn.binMath("Copysign")
		case 0xa7: // i32.wrap_i64
			fn.push(&ast.CallExpr{Fun: int32Ident, Args: []ast.Expr{fn.pop()}})

		case 0xa8: // i32.trunc_f32_s
			fn.floatTrunc("i32_trunc_f32_s")
		case 0xa9: // i32.trunc_f32_u
			fn.floatTrunc("i32_trunc_f32_u")
		case 0xaa: // i32.trunc_f64_s
			fn.floatTrunc("i32_trunc_f64_s")
		case 0xab: // i32.trunc_f64_u
			fn.floatTrunc("i32_trunc_f64_u")

		case 0xae: // i64.trunc_f32_s
			fn.floatTrunc("i64_trunc_f32_s")
		case 0xaf: // i64.trunc_f32_u
			fn.floatTrunc("i64_trunc_f32_u")
		case 0xb0: // i64.trunc_f64_s
			fn.floatTrunc("i64_trunc_f64_s")
		case 0xb1: // i64.trunc_f64_u
			fn.floatTrunc("i64_trunc_f64_u")

		case 0xb2: // f32.convert_i32_s
			fn.push(&ast.CallExpr{Fun: float32Ident, Args: []ast.Expr{fn.pop()}})
		case 0xb3: // f32.convert_i32_u
			fn.push(&ast.CallExpr{Fun: float32Ident, Args: []ast.Expr{
				&ast.CallExpr{Fun: uint32Ident, Args: []ast.Expr{fn.pop()}},
			}})
		case 0xb4: // f32.convert_i64_s
			fn.push(&ast.CallExpr{Fun: float32Ident, Args: []ast.Expr{fn.pop()}})
		case 0xb5: // f32.convert_i64_u
			fn.push(&ast.CallExpr{Fun: float32Ident, Args: []ast.Expr{
				&ast.CallExpr{Fun: uint64Ident, Args: []ast.Expr{fn.pop()}},
			}})
		case 0xb6: // f32.demote_f64
			fn.push(&ast.CallExpr{Fun: float32Ident, Args: []ast.Expr{fn.pop()}})

		case 0xb7: // f64.convert_i32_s
			fn.push(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{fn.pop()}})
		case 0xb8: // f64.convert_i32_u
			fn.push(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{
				&ast.CallExpr{Fun: uint32Ident, Args: []ast.Expr{fn.pop()}},
			}})
		case 0xb9: // f64.convert_i64_s
			fn.push(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{fn.pop()}})
		case 0xba: // f64.convert_i64_u
			fn.push(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{
				&ast.CallExpr{Fun: uint64Ident, Args: []ast.Expr{fn.pop()}},
			}})
		case 0xbb: // f64.promote_f32
			fn.push(&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{fn.pop()}})

		case 0xbc: // i32.reinterpret_f32
			fn.float32bits()
		case 0xbd: // i64.reinterpret_f64
			fn.float64bits()
		case 0xbe: // f32.reinterpret_i32
			fn.float32frombits()
		case 0xbf: // f64.reinterpret_i64
			fn.float64frombits()

		case 0xfc:
			code, err := readLEB128(t.in)
			if err != nil {
				return err
			}
			switch code {
			case 0x00: // i32.trunc_sat_f32_s
				fn.floatTrunc("i32_trunc_sat_f32_s")
			case 0x01: // i32.trunc_sat_f32_u
				fn.floatTrunc("i32_trunc_sat_f32_u")
			case 0x02: // i32.trunc_sat_f64_s
				fn.floatTrunc("i32_trunc_sat_f64_s")
			case 0x03: // i32.trunc_sat_f64_u
				fn.floatTrunc("i32_trunc_sat_f64_u")
			case 0x04: // i64.trunc_sat_f32_s
				fn.floatTrunc("i64_trunc_sat_f32_s")
			case 0x05: // i64.trunc_sat_f32_u
				fn.floatTrunc("i64_trunc_sat_f32_u")
			case 0x06: // i64.trunc_sat_f64_s
				fn.floatTrunc("i64_trunc_sat_f64_s")
			case 0x07: // i64.trunc_sat_f64_u
				fn.floatTrunc("i64_trunc_sat_f64_u")
			default:
				return fmt.Errorf("unsupported opcode: 0xfc %02x", code)
			}

		default:
			return fmt.Errorf("unsupported opcode: %x", opcode)
		}
	}
}

func (fn *funcRef) branch(n uint64) ast.Stmt {
	// Returning from the function body.
	if n == 0 {
		ret := &ast.ReturnStmt{}
		if len(fn.typ.results) > 0 {
			ret.Results = make([]ast.Expr, len(fn.typ.results))
			for i := len(ret.Results) - 1; i >= 0; i-- {
				ret.Results[i] = fn.pop()
			}
		}
		return ret
	}

	// Create a label for the block we're jumping to.
	targetBlk := &fn.blocks[n]
	if targetBlk.label == nil {
		targetBlk.label = fn.makeLabel()
	}
	// If it's not a loop, set results.
	if targetBlk.loopPos == 0 {
		targetBlk.setResults(fn)
	}
	return &ast.BranchStmt{Tok: token.GOTO, Label: targetBlk.label}
}

func (fn *funcRef) binOp(op token.Token) {
	fn.push(&ast.BinaryExpr{
		Y:  fn.pop(),
		X:  fn.pop(),
		Op: op,
	})
}

func (fn *funcRef) binOpU32(op token.Token) {
	fn.push(&ast.CallExpr{
		Fun: int32Ident,
		Args: []ast.Expr{&ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint32Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op,
		}}})
}

func (fn *funcRef) binOpU64(op token.Token) {
	fn.push(&ast.CallExpr{
		Fun: int64Ident,
		Args: []ast.Expr{&ast.BinaryExpr{
			Y: &ast.CallExpr{
				Fun:  uint64Ident,
				Args: []ast.Expr{fn.pop()},
			},
			X: &ast.CallExpr{
				Fun:  uint64Ident,
				Args: []ast.Expr{fn.pop()},
			},
			Op: op,
		}}})
}

func (fn *funcRef) bitOp(name string, intIndent, uintIndent *ast.Ident) {
	fn.pkgs.add("math/bits")
	fn.push(&ast.CallExpr{
		Fun: intIndent,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("bits"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{&ast.CallExpr{
				Fun:  uintIndent,
				Args: []ast.Expr{fn.pop()},
			}},
		}},
	})
}

func (fn *funcRef) rotOp(name string, rotl bool, intIndent, uintIndent *ast.Ident) {
	var count ast.Expr = &ast.CallExpr{
		Fun:  ast.NewIdent("int"),
		Args: []ast.Expr{fn.pop()},
	}
	if !rotl {
		count = &ast.UnaryExpr{Op: token.SUB, X: count}
	}

	fn.pkgs.add("math/bits")
	fn.push(&ast.CallExpr{
		Fun: intIndent,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("bits"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{
				&ast.CallExpr{
					Fun:  uintIndent,
					Args: []ast.Expr{fn.pop()},
				},
				count,
			},
		}},
	})
}

func (fn *funcRef) uniMath(name string) {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent(name),
		},
		Args: []ast.Expr{fn.pop()},
	})
}

func (fn *funcRef) binMath(name string) {
	fn.pkgs.add("math")
	y := fn.pop()
	x := fn.pop()
	fn.push(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent(name),
		},
		Args: []ast.Expr{x, y},
	})
}

func (fn *funcRef) uniMath32(name string) {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: float32Ident,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("math"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{&ast.CallExpr{
				Fun:  float64Ident,
				Args: []ast.Expr{fn.pop()},
			}},
		}},
	})
}

func (fn *funcRef) binMath32(name string) {
	fn.pkgs.add("math")
	y := fn.pop()
	x := fn.pop()
	fn.push(&ast.CallExpr{
		Fun: float32Ident,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("math"),
				Sel: ast.NewIdent(name),
			},
			Args: []ast.Expr{
				&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{x}},
				&ast.CallExpr{Fun: float64Ident, Args: []ast.Expr{y}},
			},
		}},
	})
}

func (fn *funcRef) binBuiltin(name string) {
	y := fn.pop()
	x := fn.pop()
	fn.push(&ast.CallExpr{
		Fun:  ast.NewIdent(name),
		Args: []ast.Expr{x, y},
	})
}

func (fn *funcRef) float32bits() {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: int32Ident,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("math"),
				Sel: ast.NewIdent("Float32bits"),
			},
			Args: []ast.Expr{fn.pop()},
		}},
	})
}

func (fn *funcRef) float64bits() {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: int64Ident,
		Args: []ast.Expr{&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("math"),
				Sel: ast.NewIdent("Float64bits"),
			},
			Args: []ast.Expr{fn.pop()},
		}},
	})
}

func (fn *funcRef) float32frombits() {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent("Float32frombits"),
		},
		Args: []ast.Expr{&ast.CallExpr{
			Fun:  uint32Ident,
			Args: []ast.Expr{fn.pop()},
		}},
	})
}

func (fn *funcRef) float64frombits() {
	fn.pkgs.add("math")
	fn.push(&ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("math"),
			Sel: ast.NewIdent("Float64frombits"),
		},
		Args: []ast.Expr{&ast.CallExpr{
			Fun:  uint64Ident,
			Args: []ast.Expr{fn.pop()},
		}},
	})
}

func (fn *funcRef) floatTrunc(name string) {
	fn.pkgs.add("math")
	fn.hlps.add(name)
	fn.push(&ast.CallExpr{
		Fun:  ast.NewIdent(name),
		Args: []ast.Expr{fn.pop()},
	})
}

func (fn *funcRef) eqzOp() {
	fn.pushCond(&ast.BinaryExpr{
		X:  fn.pop(),
		Op: token.EQL,
		Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
	})
}

func (fn *funcRef) cmpOp(op token.Token) {
	fn.pushCond(&ast.BinaryExpr{Y: fn.pop(), X: fn.pop(), Op: op})
}

func (fn *funcRef) cmpOpU32(op token.Token) {
	fn.pushCond(&ast.BinaryExpr{
		Y: &ast.CallExpr{
			Fun:  uint32Ident,
			Args: []ast.Expr{fn.pop()},
		},
		X: &ast.CallExpr{
			Fun:  uint32Ident,
			Args: []ast.Expr{fn.pop()},
		},
		Op: op})
}

func (fn *funcRef) cmpOpU64(op token.Token) {
	fn.pushCond(&ast.BinaryExpr{
		Y: &ast.CallExpr{
			Fun:  uint64Ident,
			Args: []ast.Expr{fn.pop()},
		},
		X: &ast.CallExpr{
			Fun:  uint64Ident,
			Args: []ast.Expr{fn.pop()},
		},
		Op: op})
}

func (fn *funcRef) makeTempVar() *ast.Ident {
	id := ast.NewIdent("t" + strconv.Itoa(fn.temps))
	fn.temps++
	return id
}

func (fn *funcRef) makeLabel() *ast.Ident {
	lbl := ast.NewIdent("l" + strconv.Itoa(fn.labels))
	fn.labels++
	return lbl
}

func (t *translator) readBlockType() (typ funcType, err error) {
	i, err := readSignedLEB128(t.in)
	if err != nil {
		return
	}
	switch {
	case i >= 0:
		return t.types[i], nil
	case i >= -4:
		typ.results = string([]wasmType{wasmType(i + 128)})
	case i != -64:
		err = fmt.Errorf("unsupported block type: %d", i)
	}
	return
}

func readHeader(r io.Reader) error {
	var header [8]byte
	if _, err := io.ReadFull(r, header[:]); err != nil {
		return err
	}
	if magic := string(header[:4]); magic != "\x00asm" {
		return fmt.Errorf("invalid magic number: %q", magic)
	}
	if version := binary.LittleEndian.Uint32(header[4:]); version != 1 {
		return fmt.Errorf("invalid version: %d", version)
	}
	return nil
}

func createModuleStruct() ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("Module"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("memory")},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
				},
			},
		},
	}
}
