// Code generated by wasm2go. DO NOT EDIT.

package memory

import "encoding/binary"

type Module struct {
	Memory []byte
}

func New() *Module {
	m := &Module{}
	m.Memory = make([]byte, 65536)
	copy(m.Memory[0:], data0)
	copy(m.Memory[32:], data1)
	return m
}
func (m Module) Xwasm_grow(v0 int32) int32 {
	t1 := memory_grow(&m.Memory, v0)
	return t1
}
func (m Module) Xwasm_size() int32 {
	t0 := int32(len(m.Memory) >> 16)
	return t0
}
func (m Module) Xwasm_fill(v0 int32, v1 int32, v2 int32) {
	t0 := v0
	t1 := v1
	memory_fill(m.Memory, v2, t1, t0)
}
func (m Module) Xread_as_i32(v0 int32) int32 {
	t1 := int32(binary.LittleEndian.Uint32(m.Memory[uint32(v0):]))
	return t1
}
func (m Module) Xread_as_i8u(v0 int32) int32 {
	t1 := int32(m.Memory[uint32(v0)])
	return t1
}

func memory_grow(mem *[]byte, delta int32) int32 {
	oldLen := int32(len(*mem) >> 16)
	if delta == 0 {
		return oldLen
	}
	*mem = append(*mem, make([]byte, uint(delta)<<16)...)
	return oldLen
}

func memory_fill(mem []byte, n, val, dest int32) {
	x := uint(uint32(dest))
	y := x + uint(uint32(n))

	buf := mem[x:y]
	if byte(val) == 0 {
		clear(buf)
		return
	}

	buf[0] = byte(val)
	for i := 1; i < len(buf); {
		chunk := min(i, 8192)
		i += copy(buf[i:], buf[:chunk])
	}
}

const (
	data0 = "ghip\xaa\xff\xdf\xcb\x12\xa12\xb3\xa5\x1f\x01\x02"
	data1 = "\x01\x03\x05\a\t\v\r\x0f"
)
