// Code generated by wasm2go. DO NOT EDIT.

package memory

import "encoding/binary"

type Module struct {
	Memory []byte
}

func New() *Module {
	m := &Module{}
	m.Memory = make([]byte, 65536)
	copy(m.Memory[0:], "ghip\xaa\xff\xdf\xcb\x12\xa12\xb3\xa5\x1f\x01\x02")
	copy(m.Memory[32:], "\x01\x03\x05\a\t\v\r\x0f")
	return m
}
func (m Module) Wasm_grow(v0 int32) int32 {
	return memoryGrow(&m.Memory, v0)
}
func (m Module) Wasm_size() int32 {
	return int32(len(m.Memory) >> 16)
}
func (m Module) Wasm_fill(v0 int32, v1 int32, v2 int32) {
	t0 := v0
	t1 := v1
	memoryFill(m.Memory, v2, t1, t0)
}
func (m Module) Read_as_i32(v0 int32) int32 {
	return int32(binary.LittleEndian.Uint32(m.Memory[int(v0)+int(0):]))
}
func (m Module) Read_as_i8u(v0 int32) int32 {
	return int32(m.Memory[int(v0)+int(0)])
}

func memoryGrow(mem *[]byte, delta int32) int32 {
	oldLen := int32(len(*mem) >> 16)
	if delta == 0 {
		return oldLen
	}
	*mem = append(*mem, make([]byte, uint(delta)<<16)...)
	return oldLen
}

func memoryFill(mem []byte, n, val, dest int32) {
	x := uint(uint32(dest))
	y := x + uint(uint32(n))

	buf := mem[x:y]
	if byte(val) == 0 {
		clear(buf)
		return
	}

	buf[0] = byte(val)
	for i := 1; i < len(buf); {
		chunk := min(i, 8192)
		i += copy(buf[i:], buf[:chunk])
	}
}
