// Code generated by wasm2go. DO NOT EDIT.

package wasm2go

import "encoding/binary"

type Module struct {
	Memory []byte
	maxMem int32
}

func New() *Module {
	m := &Module{}
	m.maxMem = 100
	m.Memory = make([]byte, 65536)
	copy(m.Memory[0:], data0)
	copy(m.Memory[32:], data1)
	return m
}
func (m *Module) Xwasm_grow(v0 int32) int32 {
	t0 := v0
	t1 := memory_grow(&m.Memory, t0, m.maxMem)
	return t1
}
func (m *Module) Xwasm_size() int32 {
	t0 := int32(len(m.Memory) >> 16)
	return t0
}
func (m *Module) Xwasm_fill(v0 int32, v1 int32, v2 int32) {
	t0 := v0
	t1 := v1
	t2 := v2
	memory_fill(m.Memory, t2, t1, t0)
}
func (m *Module) Xread_as_i32(v0 int32) int32 {
	t0 := v0
	t1 := int32(binary.LittleEndian.Uint32(m.Memory[uint32(t0):]))
	return t1
}
func (m *Module) Xread_as_i8u(v0 int32) int32 {
	t0 := v0
	t1 := int32(m.Memory[uint32(t0)])
	return t1
}

func memory_grow(mem *[]byte, delta, max int32) int32 {
	buf := *mem
	len := len(buf)
	old := int32(len >> 16)
	if delta == 0 {
		return old
	}
	new := old + delta
	add := int(new)<<16 - len
	if new > max || add < 0 {
		return -1
	}
	*mem = append(buf, make([]byte, add)...)
	return old
}

func memory_fill(mem []byte, n, val, dest int32) {
	x := uint(uint32(dest))
	y := x + uint(uint32(n))

	buf := mem[x:y]
	buf[0] = byte(val)
	for i := 1; i < len(buf); {
		chunk := min(i, 8192)
		i += copy(buf[i:], buf[:chunk])
	}
}

const (
	data0 = "ghip\xaa\xff\xdf\xcb\x12\xa12\xb3\xa5\x1f\x01\x02"
	data1 = "\x01\x03\x05\a\t\v\r\x0f"
)
