// Code generated by wasm2go. DO NOT EDIT.

package memory

import (
	"encoding/binary"
	"math"
)

type Module struct {
	Memory       []byte
	MemoryMaxLen int
}

func New() *Module {
	m := &Module{}
	m.Memory = make([]byte, 65536)
	m.MemoryMaxLen = min(math.MaxInt, 6553600)
	copy(m.Memory[0:], data0)
	copy(m.Memory[32:], data1)
	return m
}
func (m *Module) Xwasm_grow(v0 int32) int32 {
	t0 := v0
	t1 := memory_grow(&m.Memory, t0, m.MemoryMaxLen)
	return t1
}
func (m *Module) Xwasm_size() int32 {
	t0 := int32(len(m.Memory) >> 16)
	return t0
}
func (m *Module) Xwasm_fill(v0 int32, v1 int32, v2 int32) {
	t0 := v0
	t1 := v1
	t2 := v2
	memory_fill(m.Memory, t2, t1, t0)
}
func (m *Module) Xread_as_i32(v0 int32) int32 {
	t0 := v0
	t1 := int32(binary.LittleEndian.Uint32(m.Memory[uint32(t0):]))
	return t1
}
func (m *Module) Xread_as_i8u(v0 int32) int32 {
	t0 := v0
	t1 := int32(m.Memory[uint32(t0)])
	return t1
}

func memory_grow(mem *[]byte, delta int32, max int) int32 {
	buf := *mem
	old := int32(len(buf) >> 16)
	if delta == 0 {
		return old
	}
	add := int(uint32(delta)) << 16
	new := add + len(buf)
	if 0 < new && new <= max {
		*mem = append(buf, make([]byte, add)...)
		return old
	}
	return -1
}

func memory_fill(mem []byte, n, val, dest int32) {
	x := uint(uint32(dest))
	y := x + uint(uint32(n))

	buf := mem[x:y]
	if byte(val) == 0 {
		clear(buf)
		return
	}

	buf[0] = byte(val)
	for i := 1; i < len(buf); {
		chunk := min(i, 8192)
		i += copy(buf[i:], buf[:chunk])
	}
}

const (
	data0 = "ghip\xaa\xff\xdf\xcb\x12\xa12\xb3\xa5\x1f\x01\x02"
	data1 = "\x01\x03\x05\a\t\v\r\x0f"
)
